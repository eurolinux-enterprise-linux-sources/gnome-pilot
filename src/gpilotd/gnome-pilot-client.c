/* Generated by GOB (v2.0.15)   (do not edit directly) */

/* End world hunger, donate to the World Food Programme, http://www.wfp.org */

#define GOB_VERSION_MAJOR 2
#define GOB_VERSION_MINOR 0
#define GOB_VERSION_PATCHLEVEL 15

#define selfp (self->_priv)

#include <string.h> /* memset() */

#include "gnome-pilot-client.h"

#include "gnome-pilot-client-private.h"

#ifdef G_LIKELY
#define ___GOB_LIKELY(expr) G_LIKELY(expr)
#define ___GOB_UNLIKELY(expr) G_UNLIKELY(expr)
#else /* ! G_LIKELY */
#define ___GOB_LIKELY(expr) (expr)
#define ___GOB_UNLIKELY(expr) (expr)
#endif /* G_LIKELY */

#line 62 "gnome-pilot-client.gob"


#include <sys/types.h>
#include <signal.h>
	
typedef struct {
	POA_GNOME_Pilot_Client servant;
	GnomePilotClient *self;
} GnomePilotClientServant;

GnomePilotClient* get_self (PortableServer_Servant servant);
pid_t gpilotd_get_pid (void);

PortableServer_ServantBase__epv base_epv = {
	NULL,
	NULL,
	NULL
};

static POA_GNOME_Pilot_Client__epv  gnome_pilot_client_epv;
static POA_GNOME_Pilot_Client__vepv gnome_pilot_client_vepv = { &base_epv, &gnome_pilot_client_epv };

enum get_triple_ptr_action {
	GPILOTD_APP_PILOT_NAMES,
	GPILOTD_APP_PILOT_IDS,
	GPILOTD_APP_PILOTS_BY_NAME,
	GPILOTD_APP_PILOTS_BY_LOGIN,
	GPILOTD_APP_USER_NAMES,
	GPILOTD_APP_DATABASES_FROM_CACHE,
	GPILOTD_APP_CRADLES
};

#ifdef WITH_VFS
gboolean xfer_callback (GnomeVFSXferProgressInfo *info,
			GnomePilotClient *this);
#endif


#line 65 "gnome-pilot-client.c"
/* self casting macros */
#define SELF(x) GNOME_PILOT_CLIENT(x)
#define SELF_CONST(x) GNOME_PILOT_CLIENT_CONST(x)
#define IS_SELF(x) GNOME_IS_PILOT_CLIENT(x)
#define TYPE_SELF GNOME_TYPE_PILOT_CLIENT
#define SELF_CLASS(x) GNOME_PILOT_CLIENT_CLASS(x)

#define SELF_GET_CLASS(x) GNOME_PILOT_CLIENT_GET_CLASS(x)

/* self typedefs */
typedef GnomePilotClient Self;
typedef GnomePilotClientClass SelfClass;

/* here are local prototypes */
static void gnome_pilot_client_class_init (GnomePilotClientClass * class) G_GNUC_UNUSED;
static void gnome_pilot_client_init_corba_class (GnomePilotClient * self) G_GNUC_UNUSED;
static void gnome_pilot_client_init (GnomePilotClient * self) G_GNUC_UNUSED;
static CORBA_char * gnome_pilot_client_corba_get_client_id (PortableServer_Servant servant, CORBA_Environment * ev) G_GNUC_UNUSED;
static void gnome_pilot_client_corba_set_client_id (PortableServer_Servant servant, const CORBA_char * id, CORBA_Environment * ev) G_GNUC_UNUSED;
static void gnome_pilot_client_corba_connect (PortableServer_Servant servant, const CORBA_char * pilot_id, const GNOME_Pilot_UserInfo * user, CORBA_Environment * ev) G_GNUC_UNUSED;
static void gnome_pilot_client_corba_disconnect (PortableServer_Servant servant, const CORBA_char * pilot_id, CORBA_Environment * ev) G_GNUC_UNUSED;
static void gnome_pilot_client_corba_request_completed (PortableServer_Servant servant, const CORBA_char * pilot_id, CORBA_unsigned_long id, CORBA_Environment * ev) G_GNUC_UNUSED;
static void gnome_pilot_client_corba_user_info_requested (PortableServer_Servant servant, const CORBA_char * pilot_id, const GNOME_Pilot_UserInfo * user, CORBA_Environment * ev) G_GNUC_UNUSED;
static void gnome_pilot_client_corba_system_info_requested (PortableServer_Servant servant, const CORBA_char * device, const GNOME_Pilot_SysInfo * sysinfo, CORBA_Environment * ev) G_GNUC_UNUSED;
static void gnome_pilot_client_corba_conduit_start (PortableServer_Servant servant, const CORBA_char * pilot_id, const CORBA_char * conduit_name, const CORBA_char * database, CORBA_Environment * ev) G_GNUC_UNUSED;
static void gnome_pilot_client_corba_conduit_end (PortableServer_Servant servant, const CORBA_char * pilot_id, const CORBA_char * conduit_name, CORBA_Environment * ev) G_GNUC_UNUSED;
static void gnome_pilot_client_corba_overall_progress (PortableServer_Servant servant, const CORBA_char * pilot_id, const CORBA_unsigned_long current, const CORBA_unsigned_long total, CORBA_Environment * ev) G_GNUC_UNUSED;
static void gnome_pilot_client_corba_conduit_progress (PortableServer_Servant servant, const CORBA_char * pilot_id, const CORBA_char * conduit_name, const CORBA_unsigned_long current, const CORBA_unsigned_long total, CORBA_Environment * ev) G_GNUC_UNUSED;
static void gnome_pilot_client_corba_conduit_message (PortableServer_Servant servant, const CORBA_char * pilot_id, const CORBA_char * conduit_name, const CORBA_char * message, CORBA_Environment * ev) G_GNUC_UNUSED;
static void gnome_pilot_client_corba_daemon_message (PortableServer_Servant servant, const CORBA_char * pilot_id, const CORBA_char * conduit_name, const CORBA_char * message, CORBA_Environment * ev) G_GNUC_UNUSED;
static void gnome_pilot_client_corba_daemon_error (PortableServer_Servant servant, const CORBA_char * pilot_id, const CORBA_char * message, CORBA_Environment * ev) G_GNUC_UNUSED;
static void gnome_pilot_client_corba_conduit_error (PortableServer_Servant servant, const CORBA_char * pilot_id, const CORBA_char * conduit_name, const CORBA_char * message, CORBA_Environment * ev) G_GNUC_UNUSED;
static void gnome_pilot_client_corba_pause (PortableServer_Servant servant, const CORBA_boolean on_off, CORBA_Environment * ev) G_GNUC_UNUSED;
static void ___real_gnome_pilot_client_pilot_connect (GnomePilotClient * self, const gchar * pilot_name, const GNOME_Pilot_UserInfo * userinfo);
static void ___real_gnome_pilot_client_pilot_disconnect (GnomePilotClient * self, const gchar * pilot_name);
static void ___real_gnome_pilot_client_completed_request (GnomePilotClient * self, const gchar * pilot_name, unsigned long request_id);
static void ___real_gnome_pilot_client_user_info (GnomePilotClient * self, const gchar * device, const GNOME_Pilot_UserInfo * userinfo);
static void ___real_gnome_pilot_client_system_info (GnomePilotClient * self, const gchar * device, const GNOME_Pilot_SysInfo * sysinfo);
static void ___real_gnome_pilot_client_start_conduit (GnomePilotClient * self, const gchar * pilot_name, const gchar * conduit_name, const gchar * database);
static void ___real_gnome_pilot_client_end_conduit (GnomePilotClient * self, const gchar * pilot_name, const gchar * conduit_name);
static void ___real_gnome_pilot_client_progress_conduit (GnomePilotClient * self, const gchar * pilot_name, const gchar * conduit_name, guint current, guint total);
static void ___real_gnome_pilot_client_message_conduit (GnomePilotClient * self, const gchar * pilot_name, const gchar * conduit_name, const gchar * message);
static void ___real_gnome_pilot_client_message_daemon (GnomePilotClient * self, const gchar * pilot_name, const gchar * conduit_name, const gchar * message);
static void ___real_gnome_pilot_client_error_daemon (GnomePilotClient * self, const gchar * pilot_name, const gchar * message);
static void ___real_gnome_pilot_client_error_conduit (GnomePilotClient * self, const gchar * pilot_name, const gchar * conduit_name, const gchar * message);
static void ___real_gnome_pilot_client_daemon_pause (GnomePilotClient * self, gboolean on_off);
static gint gnome_pilot_client_get_triple_ptr (GnomePilotClient * self, enum get_triple_ptr_action action, const gchar * name, GList ** output) G_GNUC_UNUSED;

/*
 * Signal connection wrapper macro shortcuts
 */
#define self_connect__pilot_connect(object,func,data)	gnome_pilot_client_connect__pilot_connect((object),(func),(data))
#define self_connect_after__pilot_connect(object,func,data)	gnome_pilot_client_connect_after__pilot_connect((object),(func),(data))
#define self_connect_data__pilot_connect(object,func,data,destroy_data,flags)	gnome_pilot_client_connect_data__pilot_connect((object),(func),(data),(destroy_data),(flags))
#define self_connect__pilot_disconnect(object,func,data)	gnome_pilot_client_connect__pilot_disconnect((object),(func),(data))
#define self_connect_after__pilot_disconnect(object,func,data)	gnome_pilot_client_connect_after__pilot_disconnect((object),(func),(data))
#define self_connect_data__pilot_disconnect(object,func,data,destroy_data,flags)	gnome_pilot_client_connect_data__pilot_disconnect((object),(func),(data),(destroy_data),(flags))
#define self_connect__completed_request(object,func,data)	gnome_pilot_client_connect__completed_request((object),(func),(data))
#define self_connect_after__completed_request(object,func,data)	gnome_pilot_client_connect_after__completed_request((object),(func),(data))
#define self_connect_data__completed_request(object,func,data,destroy_data,flags)	gnome_pilot_client_connect_data__completed_request((object),(func),(data),(destroy_data),(flags))
#define self_connect__user_info(object,func,data)	gnome_pilot_client_connect__user_info((object),(func),(data))
#define self_connect_after__user_info(object,func,data)	gnome_pilot_client_connect_after__user_info((object),(func),(data))
#define self_connect_data__user_info(object,func,data,destroy_data,flags)	gnome_pilot_client_connect_data__user_info((object),(func),(data),(destroy_data),(flags))
#define self_connect__system_info(object,func,data)	gnome_pilot_client_connect__system_info((object),(func),(data))
#define self_connect_after__system_info(object,func,data)	gnome_pilot_client_connect_after__system_info((object),(func),(data))
#define self_connect_data__system_info(object,func,data,destroy_data,flags)	gnome_pilot_client_connect_data__system_info((object),(func),(data),(destroy_data),(flags))
#define self_connect__start_conduit(object,func,data)	gnome_pilot_client_connect__start_conduit((object),(func),(data))
#define self_connect_after__start_conduit(object,func,data)	gnome_pilot_client_connect_after__start_conduit((object),(func),(data))
#define self_connect_data__start_conduit(object,func,data,destroy_data,flags)	gnome_pilot_client_connect_data__start_conduit((object),(func),(data),(destroy_data),(flags))
#define self_connect__end_conduit(object,func,data)	gnome_pilot_client_connect__end_conduit((object),(func),(data))
#define self_connect_after__end_conduit(object,func,data)	gnome_pilot_client_connect_after__end_conduit((object),(func),(data))
#define self_connect_data__end_conduit(object,func,data,destroy_data,flags)	gnome_pilot_client_connect_data__end_conduit((object),(func),(data),(destroy_data),(flags))
#define self_connect__progress_conduit(object,func,data)	gnome_pilot_client_connect__progress_conduit((object),(func),(data))
#define self_connect_after__progress_conduit(object,func,data)	gnome_pilot_client_connect_after__progress_conduit((object),(func),(data))
#define self_connect_data__progress_conduit(object,func,data,destroy_data,flags)	gnome_pilot_client_connect_data__progress_conduit((object),(func),(data),(destroy_data),(flags))
#define self_connect__progress_overall(object,func,data)	gnome_pilot_client_connect__progress_overall((object),(func),(data))
#define self_connect_after__progress_overall(object,func,data)	gnome_pilot_client_connect_after__progress_overall((object),(func),(data))
#define self_connect_data__progress_overall(object,func,data,destroy_data,flags)	gnome_pilot_client_connect_data__progress_overall((object),(func),(data),(destroy_data),(flags))
#define self_connect__message_conduit(object,func,data)	gnome_pilot_client_connect__message_conduit((object),(func),(data))
#define self_connect_after__message_conduit(object,func,data)	gnome_pilot_client_connect_after__message_conduit((object),(func),(data))
#define self_connect_data__message_conduit(object,func,data,destroy_data,flags)	gnome_pilot_client_connect_data__message_conduit((object),(func),(data),(destroy_data),(flags))
#define self_connect__message_daemon(object,func,data)	gnome_pilot_client_connect__message_daemon((object),(func),(data))
#define self_connect_after__message_daemon(object,func,data)	gnome_pilot_client_connect_after__message_daemon((object),(func),(data))
#define self_connect_data__message_daemon(object,func,data,destroy_data,flags)	gnome_pilot_client_connect_data__message_daemon((object),(func),(data),(destroy_data),(flags))
#define self_connect__error_daemon(object,func,data)	gnome_pilot_client_connect__error_daemon((object),(func),(data))
#define self_connect_after__error_daemon(object,func,data)	gnome_pilot_client_connect_after__error_daemon((object),(func),(data))
#define self_connect_data__error_daemon(object,func,data,destroy_data,flags)	gnome_pilot_client_connect_data__error_daemon((object),(func),(data),(destroy_data),(flags))
#define self_connect__error_conduit(object,func,data)	gnome_pilot_client_connect__error_conduit((object),(func),(data))
#define self_connect_after__error_conduit(object,func,data)	gnome_pilot_client_connect_after__error_conduit((object),(func),(data))
#define self_connect_data__error_conduit(object,func,data,destroy_data,flags)	gnome_pilot_client_connect_data__error_conduit((object),(func),(data),(destroy_data),(flags))
#define self_connect__daemon_pause(object,func,data)	gnome_pilot_client_connect__daemon_pause((object),(func),(data))
#define self_connect_after__daemon_pause(object,func,data)	gnome_pilot_client_connect_after__daemon_pause((object),(func),(data))
#define self_connect_data__daemon_pause(object,func,data,destroy_data,flags)	gnome_pilot_client_connect_data__daemon_pause((object),(func),(data),(destroy_data),(flags))

typedef void  (*___Sig1) (GnomePilotClient *, gpointer , gpointer , gpointer);

static void
___marshal_Sig1 (GClosure *closure,
	GValue *return_value G_GNUC_UNUSED,
	guint n_param_values,
	const GValue *param_values,
	gpointer invocation_hint G_GNUC_UNUSED,
	gpointer marshal_data)
{
	register ___Sig1 callback;
	register GCClosure *cc = (GCClosure*) closure;
	register gpointer data1, data2;

	g_return_if_fail (n_param_values == 3);

	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = g_value_peek_pointer (param_values + 0);
	} else {
		data1 = g_value_peek_pointer (param_values + 0);
		data2 = closure->data;
	}

	callback = (___Sig1) (marshal_data != NULL ? marshal_data : cc->callback);

	callback ((GnomePilotClient *)data1,
		(gpointer ) g_value_get_pointer (param_values + 1),
		(gpointer ) g_value_get_pointer (param_values + 2),
		data2);
}


typedef void  (*___Sig2) (GnomePilotClient *, gpointer , gpointer);

static void
___marshal_Sig2 (GClosure *closure,
	GValue *return_value G_GNUC_UNUSED,
	guint n_param_values,
	const GValue *param_values,
	gpointer invocation_hint G_GNUC_UNUSED,
	gpointer marshal_data)
{
	register ___Sig2 callback;
	register GCClosure *cc = (GCClosure*) closure;
	register gpointer data1, data2;

	g_return_if_fail (n_param_values == 2);

	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = g_value_peek_pointer (param_values + 0);
	} else {
		data1 = g_value_peek_pointer (param_values + 0);
		data2 = closure->data;
	}

	callback = (___Sig2) (marshal_data != NULL ? marshal_data : cc->callback);

	callback ((GnomePilotClient *)data1,
		(gpointer ) g_value_get_pointer (param_values + 1),
		data2);
}


typedef void  (*___Sig3) (GnomePilotClient *, gpointer , gulong , gpointer);

static void
___marshal_Sig3 (GClosure *closure,
	GValue *return_value G_GNUC_UNUSED,
	guint n_param_values,
	const GValue *param_values,
	gpointer invocation_hint G_GNUC_UNUSED,
	gpointer marshal_data)
{
	register ___Sig3 callback;
	register GCClosure *cc = (GCClosure*) closure;
	register gpointer data1, data2;

	g_return_if_fail (n_param_values == 3);

	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = g_value_peek_pointer (param_values + 0);
	} else {
		data1 = g_value_peek_pointer (param_values + 0);
		data2 = closure->data;
	}

	callback = (___Sig3) (marshal_data != NULL ? marshal_data : cc->callback);

	callback ((GnomePilotClient *)data1,
		(gpointer ) g_value_get_pointer (param_values + 1),
		(gulong ) g_value_get_ulong (param_values + 2),
		data2);
}


typedef void  (*___Sig4) (GnomePilotClient *, gpointer , gpointer , gpointer , gpointer);

static void
___marshal_Sig4 (GClosure *closure,
	GValue *return_value G_GNUC_UNUSED,
	guint n_param_values,
	const GValue *param_values,
	gpointer invocation_hint G_GNUC_UNUSED,
	gpointer marshal_data)
{
	register ___Sig4 callback;
	register GCClosure *cc = (GCClosure*) closure;
	register gpointer data1, data2;

	g_return_if_fail (n_param_values == 4);

	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = g_value_peek_pointer (param_values + 0);
	} else {
		data1 = g_value_peek_pointer (param_values + 0);
		data2 = closure->data;
	}

	callback = (___Sig4) (marshal_data != NULL ? marshal_data : cc->callback);

	callback ((GnomePilotClient *)data1,
		(gpointer ) g_value_get_pointer (param_values + 1),
		(gpointer ) g_value_get_pointer (param_values + 2),
		(gpointer ) g_value_get_pointer (param_values + 3),
		data2);
}


typedef void  (*___Sig5) (GnomePilotClient *, gpointer , gpointer , guint , guint , gpointer);

static void
___marshal_Sig5 (GClosure *closure,
	GValue *return_value G_GNUC_UNUSED,
	guint n_param_values,
	const GValue *param_values,
	gpointer invocation_hint G_GNUC_UNUSED,
	gpointer marshal_data)
{
	register ___Sig5 callback;
	register GCClosure *cc = (GCClosure*) closure;
	register gpointer data1, data2;

	g_return_if_fail (n_param_values == 5);

	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = g_value_peek_pointer (param_values + 0);
	} else {
		data1 = g_value_peek_pointer (param_values + 0);
		data2 = closure->data;
	}

	callback = (___Sig5) (marshal_data != NULL ? marshal_data : cc->callback);

	callback ((GnomePilotClient *)data1,
		(gpointer ) g_value_get_pointer (param_values + 1),
		(gpointer ) g_value_get_pointer (param_values + 2),
		(guint ) g_value_get_uint (param_values + 3),
		(guint ) g_value_get_uint (param_values + 4),
		data2);
}


typedef void  (*___Sig6) (GnomePilotClient *, gpointer , guint , guint , gpointer);

static void
___marshal_Sig6 (GClosure *closure,
	GValue *return_value G_GNUC_UNUSED,
	guint n_param_values,
	const GValue *param_values,
	gpointer invocation_hint G_GNUC_UNUSED,
	gpointer marshal_data)
{
	register ___Sig6 callback;
	register GCClosure *cc = (GCClosure*) closure;
	register gpointer data1, data2;

	g_return_if_fail (n_param_values == 4);

	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = g_value_peek_pointer (param_values + 0);
	} else {
		data1 = g_value_peek_pointer (param_values + 0);
		data2 = closure->data;
	}

	callback = (___Sig6) (marshal_data != NULL ? marshal_data : cc->callback);

	callback ((GnomePilotClient *)data1,
		(gpointer ) g_value_get_pointer (param_values + 1),
		(guint ) g_value_get_uint (param_values + 2),
		(guint ) g_value_get_uint (param_values + 3),
		data2);
}


typedef void  (*___Sig7) (GnomePilotClient *, gboolean , gpointer);

static void
___marshal_Sig7 (GClosure *closure,
	GValue *return_value G_GNUC_UNUSED,
	guint n_param_values,
	const GValue *param_values,
	gpointer invocation_hint G_GNUC_UNUSED,
	gpointer marshal_data)
{
	register ___Sig7 callback;
	register GCClosure *cc = (GCClosure*) closure;
	register gpointer data1, data2;

	g_return_if_fail (n_param_values == 2);

	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = g_value_peek_pointer (param_values + 0);
	} else {
		data1 = g_value_peek_pointer (param_values + 0);
		data2 = closure->data;
	}

	callback = (___Sig7) (marshal_data != NULL ? marshal_data : cc->callback);

	callback ((GnomePilotClient *)data1,
		(gboolean ) g_value_get_boolean (param_values + 1),
		data2);
}


enum {
	PILOT_CONNECT_SIGNAL,
	PILOT_DISCONNECT_SIGNAL,
	COMPLETED_REQUEST_SIGNAL,
	USER_INFO_SIGNAL,
	SYSTEM_INFO_SIGNAL,
	START_CONDUIT_SIGNAL,
	END_CONDUIT_SIGNAL,
	PROGRESS_CONDUIT_SIGNAL,
	PROGRESS_OVERALL_SIGNAL,
	MESSAGE_CONDUIT_SIGNAL,
	MESSAGE_DAEMON_SIGNAL,
	ERROR_DAEMON_SIGNAL,
	ERROR_CONDUIT_SIGNAL,
	DAEMON_PAUSE_SIGNAL,
	LAST_SIGNAL
};

static guint object_signals[LAST_SIGNAL] = {0};

/* pointer to the class of our parent */
static GtkObjectClass *parent_class = NULL;

/* Short form macros */
#define self_init_corba_class gnome_pilot_client_init_corba_class
#define self_new gnome_pilot_client_new
#define self_destroy gnome_pilot_client_destroy
#define self_connect_to_daemon gnome_pilot_client_connect_to_daemon
#define self_corba_get_client_id gnome_pilot_client_corba_get_client_id
#define self_corba_set_client_id gnome_pilot_client_corba_set_client_id
#define self_corba_connect gnome_pilot_client_corba_connect
#define self_corba_disconnect gnome_pilot_client_corba_disconnect
#define self_corba_request_completed gnome_pilot_client_corba_request_completed
#define self_corba_user_info_requested gnome_pilot_client_corba_user_info_requested
#define self_corba_system_info_requested gnome_pilot_client_corba_system_info_requested
#define self_corba_conduit_start gnome_pilot_client_corba_conduit_start
#define self_corba_conduit_end gnome_pilot_client_corba_conduit_end
#define self_corba_overall_progress gnome_pilot_client_corba_overall_progress
#define self_corba_conduit_progress gnome_pilot_client_corba_conduit_progress
#define self_corba_conduit_message gnome_pilot_client_corba_conduit_message
#define self_corba_daemon_message gnome_pilot_client_corba_daemon_message
#define self_corba_daemon_error gnome_pilot_client_corba_daemon_error
#define self_corba_conduit_error gnome_pilot_client_corba_conduit_error
#define self_corba_pause gnome_pilot_client_corba_pause
#define self_pilot_connect gnome_pilot_client_pilot_connect
#define self_pilot_disconnect gnome_pilot_client_pilot_disconnect
#define self_completed_request gnome_pilot_client_completed_request
#define self_user_info gnome_pilot_client_user_info
#define self_system_info gnome_pilot_client_system_info
#define self_start_conduit gnome_pilot_client_start_conduit
#define self_end_conduit gnome_pilot_client_end_conduit
#define self_progress_conduit gnome_pilot_client_progress_conduit
#define self_progress_overall gnome_pilot_client_progress_overall
#define self_message_conduit gnome_pilot_client_message_conduit
#define self_message_daemon gnome_pilot_client_message_daemon
#define self_error_daemon gnome_pilot_client_error_daemon
#define self_error_conduit gnome_pilot_client_error_conduit
#define self_daemon_pause gnome_pilot_client_daemon_pause
#define self_pause_daemon gnome_pilot_client_pause_daemon
#define self_unpause_daemon gnome_pilot_client_unpause_daemon
#define self_reread_config gnome_pilot_client_reread_config
#define self_noop gnome_pilot_client_noop
#define self_restart_daemon gnome_pilot_client_restart_daemon
#define self_monitor_on gnome_pilot_client_monitor_on
#define self_monitor_on_all_pilots gnome_pilot_client_monitor_on_all_pilots
#define self_monitor_off gnome_pilot_client_monitor_off
#define self_monitor_off_all_pilots gnome_pilot_client_monitor_off_all_pilots
#define self_notify_on gnome_pilot_client_notify_on
#define self_notify_off gnome_pilot_client_notify_off
#define self_restore gnome_pilot_client_restore
#define self_install_file gnome_pilot_client_install_file
#define self_get_user_info gnome_pilot_client_get_user_info
#define self_set_user_info gnome_pilot_client_set_user_info
#define self_get_system_info gnome_pilot_client_get_system_info
#define self_remove_request gnome_pilot_client_remove_request
#define self_conduit gnome_pilot_client_conduit
#define self_get_triple_ptr gnome_pilot_client_get_triple_ptr
#define self_get_users gnome_pilot_client_get_users
#define self_get_databases_from_cache gnome_pilot_client_get_databases_from_cache
#define self_get_cradles gnome_pilot_client_get_cradles
#define self_get_pilots gnome_pilot_client_get_pilots
#define self_get_pilot_ids gnome_pilot_client_get_pilot_ids
#define self_get_pilots_by_user_name gnome_pilot_client_get_pilots_by_user_name
#define self_get_pilots_by_user_login gnome_pilot_client_get_pilots_by_user_login
#define self_get_user_name_by_pilot_name gnome_pilot_client_get_user_name_by_pilot_name
#define self_get_user_login_by_pilot_name gnome_pilot_client_get_user_login_by_pilot_name
#define self_get_pilot_base_dir_by_name gnome_pilot_client_get_pilot_base_dir_by_name
#define self_get_pilot_base_dir_by_id gnome_pilot_client_get_pilot_base_dir_by_id
#define self_get_pilot_id_by_name gnome_pilot_client_get_pilot_id_by_name
#define self_get_pilot_name_by_id gnome_pilot_client_get_pilot_name_by_id
GType
gnome_pilot_client_get_type (void)
{
	static GType type = 0;

	if ___GOB_UNLIKELY(type == 0) {
		static const GTypeInfo info = {
			sizeof (GnomePilotClientClass),
			(GBaseInitFunc) NULL,
			(GBaseFinalizeFunc) NULL,
			(GClassInitFunc) gnome_pilot_client_class_init,
			(GClassFinalizeFunc) NULL,
			NULL /* class_data */,
			sizeof (GnomePilotClient),
			0 /* n_preallocs */,
			(GInstanceInitFunc) gnome_pilot_client_init,
			NULL
		};

		type = g_type_register_static (GTK_TYPE_OBJECT, "GnomePilotClient", &info, (GTypeFlags)0);
	}

	return type;
}

/* a macro for creating a new object of our type */
#define GET_NEW ((GnomePilotClient *)g_object_new(gnome_pilot_client_get_type(), NULL))

/* a function for creating a new object of our type */
#include <stdarg.h>
static GnomePilotClient * GET_NEW_VARG (const char *first, ...) G_GNUC_UNUSED;
static GnomePilotClient *
GET_NEW_VARG (const char *first, ...)
{
	GnomePilotClient *ret;
	va_list ap;
	va_start (ap, first);
	ret = (GnomePilotClient *)g_object_new_valist (gnome_pilot_client_get_type (), first, ap);
	va_end (ap);
	return ret;
}

#line 108 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_class_init (GnomePilotClientClass * class G_GNUC_UNUSED)
#line 528 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::class_init"
	GObjectClass *g_object_class G_GNUC_UNUSED = (GObjectClass*) class;

	parent_class = g_type_class_ref (GTK_TYPE_OBJECT);

	object_signals[PILOT_CONNECT_SIGNAL] =
		g_signal_new ("pilot_connect",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GnomePilotClientClass, pilot_connect),
			NULL, NULL,
			___marshal_Sig1,
			G_TYPE_NONE, 2,
			G_TYPE_POINTER,
			G_TYPE_POINTER);
	if ___GOB_UNLIKELY(sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(const GNOME_Pilot_UserInfo * ) != sizeof(gpointer ) || parent_class == NULL /* avoid warning */) {
		g_error("gnome-pilot-client.gob line 384: Type mismatch of \"pilot_connect\" signal signature");
	}
	object_signals[PILOT_DISCONNECT_SIGNAL] =
		g_signal_new ("pilot_disconnect",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GnomePilotClientClass, pilot_disconnect),
			NULL, NULL,
			___marshal_Sig2,
			G_TYPE_NONE, 1,
			G_TYPE_POINTER);
	if ___GOB_UNLIKELY(sizeof(const gchar * ) != sizeof(gpointer ) || parent_class == NULL /* avoid warning */) {
		g_error("gnome-pilot-client.gob line 389: Type mismatch of \"pilot_disconnect\" signal signature");
	}
	object_signals[COMPLETED_REQUEST_SIGNAL] =
		g_signal_new ("completed_request",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GnomePilotClientClass, completed_request),
			NULL, NULL,
			___marshal_Sig3,
			G_TYPE_NONE, 2,
			G_TYPE_POINTER,
			G_TYPE_ULONG);
	if ___GOB_UNLIKELY(sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(unsigned long ) != sizeof(gulong ) || parent_class == NULL /* avoid warning */) {
		g_error("gnome-pilot-client.gob line 394: Type mismatch of \"completed_request\" signal signature");
	}
	object_signals[USER_INFO_SIGNAL] =
		g_signal_new ("user_info",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GnomePilotClientClass, user_info),
			NULL, NULL,
			___marshal_Sig1,
			G_TYPE_NONE, 2,
			G_TYPE_POINTER,
			G_TYPE_POINTER);
	if ___GOB_UNLIKELY(sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(const GNOME_Pilot_UserInfo * ) != sizeof(gpointer ) || parent_class == NULL /* avoid warning */) {
		g_error("gnome-pilot-client.gob line 399: Type mismatch of \"user_info\" signal signature");
	}
	object_signals[SYSTEM_INFO_SIGNAL] =
		g_signal_new ("system_info",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GnomePilotClientClass, system_info),
			NULL, NULL,
			___marshal_Sig1,
			G_TYPE_NONE, 2,
			G_TYPE_POINTER,
			G_TYPE_POINTER);
	if ___GOB_UNLIKELY(sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(const GNOME_Pilot_SysInfo * ) != sizeof(gpointer ) || parent_class == NULL /* avoid warning */) {
		g_error("gnome-pilot-client.gob line 404: Type mismatch of \"system_info\" signal signature");
	}
	object_signals[START_CONDUIT_SIGNAL] =
		g_signal_new ("start_conduit",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GnomePilotClientClass, start_conduit),
			NULL, NULL,
			___marshal_Sig4,
			G_TYPE_NONE, 3,
			G_TYPE_POINTER,
			G_TYPE_POINTER,
			G_TYPE_POINTER);
	if ___GOB_UNLIKELY(sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(const gchar * ) != sizeof(gpointer ) || parent_class == NULL /* avoid warning */) {
		g_error("gnome-pilot-client.gob line 409: Type mismatch of \"start_conduit\" signal signature");
	}
	object_signals[END_CONDUIT_SIGNAL] =
		g_signal_new ("end_conduit",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GnomePilotClientClass, end_conduit),
			NULL, NULL,
			___marshal_Sig1,
			G_TYPE_NONE, 2,
			G_TYPE_POINTER,
			G_TYPE_POINTER);
	if ___GOB_UNLIKELY(sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(const gchar * ) != sizeof(gpointer ) || parent_class == NULL /* avoid warning */) {
		g_error("gnome-pilot-client.gob line 414: Type mismatch of \"end_conduit\" signal signature");
	}
	object_signals[PROGRESS_CONDUIT_SIGNAL] =
		g_signal_new ("progress_conduit",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GnomePilotClientClass, progress_conduit),
			NULL, NULL,
			___marshal_Sig5,
			G_TYPE_NONE, 4,
			G_TYPE_POINTER,
			G_TYPE_POINTER,
			G_TYPE_UINT,
			G_TYPE_UINT);
	if ___GOB_UNLIKELY(sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(guint ) != sizeof(guint ) || sizeof(guint ) != sizeof(guint ) || parent_class == NULL /* avoid warning */) {
		g_error("gnome-pilot-client.gob line 419: Type mismatch of \"progress_conduit\" signal signature");
	}
	object_signals[PROGRESS_OVERALL_SIGNAL] =
		g_signal_new ("progress_overall",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GnomePilotClientClass, progress_overall),
			NULL, NULL,
			___marshal_Sig6,
			G_TYPE_NONE, 3,
			G_TYPE_POINTER,
			G_TYPE_UINT,
			G_TYPE_UINT);
	if ___GOB_UNLIKELY(sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(guint ) != sizeof(guint ) || sizeof(guint ) != sizeof(guint ) || parent_class == NULL /* avoid warning */) {
		g_error("gnome-pilot-client.gob line 424: Type mismatch of \"progress_overall\" signal signature");
	}
	object_signals[MESSAGE_CONDUIT_SIGNAL] =
		g_signal_new ("message_conduit",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GnomePilotClientClass, message_conduit),
			NULL, NULL,
			___marshal_Sig4,
			G_TYPE_NONE, 3,
			G_TYPE_POINTER,
			G_TYPE_POINTER,
			G_TYPE_POINTER);
	if ___GOB_UNLIKELY(sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(const gchar * ) != sizeof(gpointer ) || parent_class == NULL /* avoid warning */) {
		g_error("gnome-pilot-client.gob line 430: Type mismatch of \"message_conduit\" signal signature");
	}
	object_signals[MESSAGE_DAEMON_SIGNAL] =
		g_signal_new ("message_daemon",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GnomePilotClientClass, message_daemon),
			NULL, NULL,
			___marshal_Sig4,
			G_TYPE_NONE, 3,
			G_TYPE_POINTER,
			G_TYPE_POINTER,
			G_TYPE_POINTER);
	if ___GOB_UNLIKELY(sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(const gchar * ) != sizeof(gpointer ) || parent_class == NULL /* avoid warning */) {
		g_error("gnome-pilot-client.gob line 435: Type mismatch of \"message_daemon\" signal signature");
	}
	object_signals[ERROR_DAEMON_SIGNAL] =
		g_signal_new ("error_daemon",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GnomePilotClientClass, error_daemon),
			NULL, NULL,
			___marshal_Sig1,
			G_TYPE_NONE, 2,
			G_TYPE_POINTER,
			G_TYPE_POINTER);
	if ___GOB_UNLIKELY(sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(const gchar * ) != sizeof(gpointer ) || parent_class == NULL /* avoid warning */) {
		g_error("gnome-pilot-client.gob line 440: Type mismatch of \"error_daemon\" signal signature");
	}
	object_signals[ERROR_CONDUIT_SIGNAL] =
		g_signal_new ("error_conduit",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GnomePilotClientClass, error_conduit),
			NULL, NULL,
			___marshal_Sig4,
			G_TYPE_NONE, 3,
			G_TYPE_POINTER,
			G_TYPE_POINTER,
			G_TYPE_POINTER);
	if ___GOB_UNLIKELY(sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(const gchar * ) != sizeof(gpointer ) || sizeof(const gchar * ) != sizeof(gpointer ) || parent_class == NULL /* avoid warning */) {
		g_error("gnome-pilot-client.gob line 445: Type mismatch of \"error_conduit\" signal signature");
	}
	object_signals[DAEMON_PAUSE_SIGNAL] =
		g_signal_new ("daemon_pause",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GnomePilotClientClass, daemon_pause),
			NULL, NULL,
			___marshal_Sig7,
			G_TYPE_NONE, 1,
			G_TYPE_BOOLEAN);
	if ___GOB_UNLIKELY(sizeof(gboolean ) != sizeof(gboolean ) || parent_class == NULL /* avoid warning */) {
		g_error("gnome-pilot-client.gob line 450: Type mismatch of \"daemon_pause\" signal signature");
	}

#line 384 "gnome-pilot-client.gob"
	class->pilot_connect = ___real_gnome_pilot_client_pilot_connect;
#line 389 "gnome-pilot-client.gob"
	class->pilot_disconnect = ___real_gnome_pilot_client_pilot_disconnect;
#line 394 "gnome-pilot-client.gob"
	class->completed_request = ___real_gnome_pilot_client_completed_request;
#line 399 "gnome-pilot-client.gob"
	class->user_info = ___real_gnome_pilot_client_user_info;
#line 404 "gnome-pilot-client.gob"
	class->system_info = ___real_gnome_pilot_client_system_info;
#line 409 "gnome-pilot-client.gob"
	class->start_conduit = ___real_gnome_pilot_client_start_conduit;
#line 414 "gnome-pilot-client.gob"
	class->end_conduit = ___real_gnome_pilot_client_end_conduit;
#line 419 "gnome-pilot-client.gob"
	class->progress_conduit = ___real_gnome_pilot_client_progress_conduit;
#line 739 "gnome-pilot-client.c"
	class->progress_overall = NULL;
#line 430 "gnome-pilot-client.gob"
	class->message_conduit = ___real_gnome_pilot_client_message_conduit;
#line 435 "gnome-pilot-client.gob"
	class->message_daemon = ___real_gnome_pilot_client_message_daemon;
#line 440 "gnome-pilot-client.gob"
	class->error_daemon = ___real_gnome_pilot_client_error_daemon;
#line 445 "gnome-pilot-client.gob"
	class->error_conduit = ___real_gnome_pilot_client_error_conduit;
#line 450 "gnome-pilot-client.gob"
	class->daemon_pause = ___real_gnome_pilot_client_daemon_pause;
#line 751 "gnome-pilot-client.c"
 {
#line 108 "gnome-pilot-client.gob"

#ifdef WITH_VFS
		if (gnome_vfs_initialized () == FALSE) {
			g_message ("Initing gnome vfs");
			if (gnome_vfs_init () == FALSE) {
				g_warning ("Failed to init gnome-vfs");
			}
		}
#endif /* WITH_VFS */
	
#line 764 "gnome-pilot-client.c"
 }
}
#undef __GOB_FUNCTION__
#line 144 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_init (GnomePilotClient * self G_GNUC_UNUSED)
#line 771 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::init"
 {
#line 144 "gnome-pilot-client.gob"

			int argc=0;
			char *argv=NULL;
			CORBA_Environment *ev;
			PortableServer_POA the_poa;
			GnomePilotClientServant *gnome_pilot_client_servant;

			ev = &(self->ev);
			self_init_corba_class (self);

			CORBA_exception_init (ev);

			if (!bonobo_activation_is_initialized ())
				self->orb = bonobo_activation_init (argc, &argv);
			else
				self->orb = bonobo_activation_orb_get ();

			g_assert (self->orb!=NULL);
					
			gnome_pilot_client_servant = g_new0(GnomePilotClientServant,1);
			gnome_pilot_client_servant->servant.vepv = 
			                            &gnome_pilot_client_vepv;
			gnome_pilot_client_servant->self = self;
			
			the_poa = (PortableServer_POA)CORBA_ORB_resolve_initial_references (self->orb,"RootPOA",ev);
			if (ev->_major != CORBA_NO_EXCEPTION) {
				g_warning ("%s:%d: Caught exception: %s",
					   __FILE__,__LINE__, 
					   CORBA_exception_id (ev));
				CORBA_exception_free (ev);
			}

			PortableServer_POAManager_activate (PortableServer_POA__get_the_POAManager (the_poa, ev), ev);
			if (ev->_major != CORBA_NO_EXCEPTION) {
				g_warning ("%s:%d: Caught exception: %s",
					   __FILE__,__LINE__, 
					   CORBA_exception_id (ev));
				CORBA_exception_free (ev);
			}

			POA_GNOME_Pilot_Client__init ((PortableServer_Servant)gnome_pilot_client_servant,ev);
			if (ev->_major != CORBA_NO_EXCEPTION) {
				g_warning ("%s:%d: Caught exception: %s",
					   __FILE__,__LINE__, 
					   CORBA_exception_id (ev));
				CORBA_exception_free (ev);
			}

			CORBA_free (
				PortableServer_POA_activate_object (the_poa,
								   gnome_pilot_client_servant,
								   ev)
				);
			if (ev->_major != CORBA_NO_EXCEPTION) {
				g_warning ("%s:%d: Caught exception: %s",
					   __FILE__,__LINE__, 
					   CORBA_exception_id (ev));
				CORBA_exception_free (ev);
			}
			
			self->gpilotdclient = 
				PortableServer_POA_servant_to_reference (the_poa, 
									gnome_pilot_client_servant, 
									ev);
			if (ev->_major != CORBA_NO_EXCEPTION) {
				g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (ev));
				CORBA_exception_free (ev);
			}			
	
#line 845 "gnome-pilot-client.c"
 }
}
#undef __GOB_FUNCTION__


#line 119 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_init_corba_class (GnomePilotClient * self)
#line 854 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::init_corba_class"
#line 119 "gnome-pilot-client.gob"
	g_return_if_fail (self != NULL);
#line 119 "gnome-pilot-client.gob"
	g_return_if_fail (GNOME_IS_PILOT_CLIENT (self));
#line 861 "gnome-pilot-client.c"
{
#line 119 "gnome-pilot-client.gob"
	
		static gboolean inited = FALSE;
		
		if (inited==FALSE) {
			self->client_id = NULL;
			inited = TRUE;
			gnome_pilot_client_epv._get_client_id = self_corba_get_client_id;
			gnome_pilot_client_epv._set_client_id = self_corba_set_client_id;
			gnome_pilot_client_epv.connect = self_corba_connect;
			gnome_pilot_client_epv.disconnect = self_corba_disconnect;
			gnome_pilot_client_epv.request_completed = self_corba_request_completed;
			gnome_pilot_client_epv.userinfo_requested = self_corba_user_info_requested;
			gnome_pilot_client_epv.sysinfo_requested = self_corba_system_info_requested;
			gnome_pilot_client_epv.conduit_start = self_corba_conduit_start;
			gnome_pilot_client_epv.conduit_end = self_corba_conduit_end;
			gnome_pilot_client_epv.overall_progress = self_corba_overall_progress;
			gnome_pilot_client_epv.conduit_progress = self_corba_conduit_progress;
			gnome_pilot_client_epv.conduit_message = self_corba_conduit_message;
			gnome_pilot_client_epv.daemon_message = self_corba_daemon_message;
			gnome_pilot_client_epv.daemon_error = self_corba_daemon_error;
			gnome_pilot_client_epv.conduit_error = self_corba_conduit_error;
			gnome_pilot_client_epv.pause = self_corba_pause;
		}
	}}
#line 888 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__


#line 214 "gnome-pilot-client.gob"
GtkObject * 
gnome_pilot_client_new (void)
#line 895 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::new"
{
#line 215 "gnome-pilot-client.gob"
	
		GnomePilotClient *ret = GET_NEW;
		return GTK_OBJECT (ret);
	}}
#line 904 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 220 "gnome-pilot-client.gob"
void 
gnome_pilot_client_destroy (GnomePilotClient * self)
#line 910 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::destroy"
#line 220 "gnome-pilot-client.gob"
	g_return_if_fail (self != NULL);
#line 220 "gnome-pilot-client.gob"
	g_return_if_fail (GNOME_IS_PILOT_CLIENT (self));
#line 917 "gnome-pilot-client.c"
{
#line 220 "gnome-pilot-client.gob"
	
		g_free (self->client_id);
		/* FIXME: ick, what more to do here ? */
        }}
#line 924 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 225 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_connect_to_daemon (GnomePilotClient * self)
#line 930 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::connect_to_daemon"
#line 225 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )0);
#line 225 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )0);
#line 937 "gnome-pilot-client.c"
{
#line 225 "gnome-pilot-client.gob"
	
		Bonobo_ServerInfoList *list;
		CORBA_Environment *ev;
		
		ev = &(self->ev);
		list = bonobo_activation_query ("repo_ids.has ('IDL:GNOME/Pilot/Daemon:2.0')", NULL, ev);
		if (list->_length == 0) {
			return GPILOTD_ERR_NOT_CONNECTED;
		} else {
			Bonobo_ServerInfo info;
			info = list->_buffer[0];
			g_message ("Activating object %s", info.iid);
			self->gpilotddaemon = bonobo_activation_activate_from_id (info.iid, 		  
									    	Bonobo_ACTIVATION_FLAG_NO_LOCAL, NULL, NULL);
		}
		CORBA_free (list);
		CORBA_exception_free (ev);

		if (self->gpilotddaemon == NULL) return GPILOTD_ERR_NOT_CONNECTED;

		return GPILOTD_OK;
	}}
#line 962 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 248 "gnome-pilot-client.gob"
static CORBA_char * 
gnome_pilot_client_corba_get_client_id (PortableServer_Servant servant, CORBA_Environment * ev)
#line 968 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::corba_get_client_id"
{
#line 250 "gnome-pilot-client.gob"
	
		gchar *id;
		id = get_self (servant)->client_id;
		if (id==NULL) return CORBA_string_dup ("");
		return CORBA_string_dup (id);
	}}
#line 979 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 257 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_corba_set_client_id (PortableServer_Servant servant, const CORBA_char * id, CORBA_Environment * ev)
#line 985 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::corba_set_client_id"
{
#line 260 "gnome-pilot-client.gob"
	
		if (get_self (servant)->client_id!=NULL) {
			/* throw exception */
		        g_assert (0);
		} get_self (servant)->client_id = g_strdup (id);
	}}
#line 996 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 267 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_corba_connect (PortableServer_Servant servant, const CORBA_char * pilot_id, const GNOME_Pilot_UserInfo * user, CORBA_Environment * ev)
#line 1002 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::corba_connect"
{
#line 271 "gnome-pilot-client.gob"
	
		self_pilot_connect (get_self (servant),pilot_id,user);
	}}
#line 1010 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 275 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_corba_disconnect (PortableServer_Servant servant, const CORBA_char * pilot_id, CORBA_Environment * ev)
#line 1016 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::corba_disconnect"
{
#line 278 "gnome-pilot-client.gob"
	
		self_pilot_disconnect (get_self (servant),pilot_id);
	}}
#line 1024 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 282 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_corba_request_completed (PortableServer_Servant servant, const CORBA_char * pilot_id, CORBA_unsigned_long id, CORBA_Environment * ev)
#line 1030 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::corba_request_completed"
{
#line 286 "gnome-pilot-client.gob"
	
		self_completed_request (get_self (servant),pilot_id,id);
	}}
#line 1038 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 290 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_corba_user_info_requested (PortableServer_Servant servant, const CORBA_char * pilot_id, const GNOME_Pilot_UserInfo * user, CORBA_Environment * ev)
#line 1044 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::corba_user_info_requested"
{
#line 294 "gnome-pilot-client.gob"
	
		self_user_info (get_self (servant),pilot_id,user);
	}}
#line 1052 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 298 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_corba_system_info_requested (PortableServer_Servant servant, const CORBA_char * device, const GNOME_Pilot_SysInfo * sysinfo, CORBA_Environment * ev)
#line 1058 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::corba_system_info_requested"
{
#line 302 "gnome-pilot-client.gob"
	
		self_system_info (get_self (servant),device,sysinfo);
	}}
#line 1066 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 306 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_corba_conduit_start (PortableServer_Servant servant, const CORBA_char * pilot_id, const CORBA_char * conduit_name, const CORBA_char * database, CORBA_Environment * ev)
#line 1072 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::corba_conduit_start"
{
#line 311 "gnome-pilot-client.gob"
	
		self_start_conduit (get_self (servant),pilot_id,conduit_name,database);
	}}
#line 1080 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 315 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_corba_conduit_end (PortableServer_Servant servant, const CORBA_char * pilot_id, const CORBA_char * conduit_name, CORBA_Environment * ev)
#line 1086 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::corba_conduit_end"
{
#line 319 "gnome-pilot-client.gob"
	
		self_end_conduit (get_self (servant),pilot_id,conduit_name);
	}}
#line 1094 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 323 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_corba_overall_progress (PortableServer_Servant servant, const CORBA_char * pilot_id, const CORBA_unsigned_long current, const CORBA_unsigned_long total, CORBA_Environment * ev)
#line 1100 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::corba_overall_progress"
{
#line 328 "gnome-pilot-client.gob"
	
		self_progress_overall (get_self (servant),pilot_id, current, total);
	}}
#line 1108 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 332 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_corba_conduit_progress (PortableServer_Servant servant, const CORBA_char * pilot_id, const CORBA_char * conduit_name, const CORBA_unsigned_long current, const CORBA_unsigned_long total, CORBA_Environment * ev)
#line 1114 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::corba_conduit_progress"
{
#line 338 "gnome-pilot-client.gob"
	
		self_progress_conduit (get_self (servant),pilot_id,conduit_name,current,total);
	}}
#line 1122 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 342 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_corba_conduit_message (PortableServer_Servant servant, const CORBA_char * pilot_id, const CORBA_char * conduit_name, const CORBA_char * message, CORBA_Environment * ev)
#line 1128 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::corba_conduit_message"
{
#line 347 "gnome-pilot-client.gob"
	
		self_message_conduit (get_self (servant),pilot_id,conduit_name,message);
	}}
#line 1136 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 351 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_corba_daemon_message (PortableServer_Servant servant, const CORBA_char * pilot_id, const CORBA_char * conduit_name, const CORBA_char * message, CORBA_Environment * ev)
#line 1142 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::corba_daemon_message"
{
#line 356 "gnome-pilot-client.gob"
	
		self_message_daemon (get_self (servant),pilot_id,conduit_name,message);
	}}
#line 1150 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 360 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_corba_daemon_error (PortableServer_Servant servant, const CORBA_char * pilot_id, const CORBA_char * message, CORBA_Environment * ev)
#line 1156 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::corba_daemon_error"
{
#line 364 "gnome-pilot-client.gob"
	
		self_error_daemon (get_self (servant), pilot_id, message);
	}}
#line 1164 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 368 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_corba_conduit_error (PortableServer_Servant servant, const CORBA_char * pilot_id, const CORBA_char * conduit_name, const CORBA_char * message, CORBA_Environment * ev)
#line 1170 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::corba_conduit_error"
{
#line 373 "gnome-pilot-client.gob"
	
		self_error_conduit (get_self (servant),pilot_id,conduit_name,message);
	}}
#line 1178 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 377 "gnome-pilot-client.gob"
static void 
gnome_pilot_client_corba_pause (PortableServer_Servant servant, const CORBA_boolean on_off, CORBA_Environment * ev)
#line 1184 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::corba_pause"
{
#line 380 "gnome-pilot-client.gob"
	
		self_daemon_pause (get_self (servant), on_off);
	}}
#line 1192 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 384 "gnome-pilot-client.gob"
void 
gnome_pilot_client_pilot_connect (GnomePilotClient * self, const gchar * pilot_name, const GNOME_Pilot_UserInfo * userinfo)
#line 1198 "gnome-pilot-client.c"
{
	GValue ___param_values[3];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 384 "gnome-pilot-client.gob"
	g_return_if_fail (self != NULL);
#line 384 "gnome-pilot-client.gob"
	g_return_if_fail (GNOME_IS_PILOT_CLIENT (self));
#line 1210 "gnome-pilot-client.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) pilot_name);

	___param_values[2].g_type = 0;
	g_value_init (&___param_values[2], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[2], (gpointer ) userinfo);

	g_signal_emitv (___param_values,
		object_signals[PILOT_CONNECT_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
	g_value_unset (&___param_values[2]);
}
#line 384 "gnome-pilot-client.gob"
static void 
___real_gnome_pilot_client_pilot_connect (GnomePilotClient * self G_GNUC_UNUSED, const gchar * pilot_name, const GNOME_Pilot_UserInfo * userinfo)
#line 1236 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::pilot_connect"
{
#line 385 "gnome-pilot-client.gob"
	
		return;
	}}
#line 1244 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 389 "gnome-pilot-client.gob"
void 
gnome_pilot_client_pilot_disconnect (GnomePilotClient * self, const gchar * pilot_name)
#line 1250 "gnome-pilot-client.c"
{
	GValue ___param_values[2];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 389 "gnome-pilot-client.gob"
	g_return_if_fail (self != NULL);
#line 389 "gnome-pilot-client.gob"
	g_return_if_fail (GNOME_IS_PILOT_CLIENT (self));
#line 1262 "gnome-pilot-client.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) pilot_name);

	g_signal_emitv (___param_values,
		object_signals[PILOT_DISCONNECT_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
}
#line 389 "gnome-pilot-client.gob"
static void 
___real_gnome_pilot_client_pilot_disconnect (GnomePilotClient * self G_GNUC_UNUSED, const gchar * pilot_name)
#line 1283 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::pilot_disconnect"
{
#line 390 "gnome-pilot-client.gob"
	
		return;
	}}
#line 1291 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 394 "gnome-pilot-client.gob"
void 
gnome_pilot_client_completed_request (GnomePilotClient * self, const gchar * pilot_name, unsigned long request_id)
#line 1297 "gnome-pilot-client.c"
{
	GValue ___param_values[3];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 394 "gnome-pilot-client.gob"
	g_return_if_fail (self != NULL);
#line 394 "gnome-pilot-client.gob"
	g_return_if_fail (GNOME_IS_PILOT_CLIENT (self));
#line 1309 "gnome-pilot-client.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) pilot_name);

	___param_values[2].g_type = 0;
	g_value_init (&___param_values[2], G_TYPE_ULONG);
	g_value_set_ulong (&___param_values[2], (gulong ) request_id);

	g_signal_emitv (___param_values,
		object_signals[COMPLETED_REQUEST_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
	g_value_unset (&___param_values[2]);
}
#line 394 "gnome-pilot-client.gob"
static void 
___real_gnome_pilot_client_completed_request (GnomePilotClient * self G_GNUC_UNUSED, const gchar * pilot_name, unsigned long request_id)
#line 1335 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::completed_request"
{
#line 395 "gnome-pilot-client.gob"
	
		return;
	}}
#line 1343 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 399 "gnome-pilot-client.gob"
void 
gnome_pilot_client_user_info (GnomePilotClient * self, const gchar * device, const GNOME_Pilot_UserInfo * userinfo)
#line 1349 "gnome-pilot-client.c"
{
	GValue ___param_values[3];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 399 "gnome-pilot-client.gob"
	g_return_if_fail (self != NULL);
#line 399 "gnome-pilot-client.gob"
	g_return_if_fail (GNOME_IS_PILOT_CLIENT (self));
#line 1361 "gnome-pilot-client.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) device);

	___param_values[2].g_type = 0;
	g_value_init (&___param_values[2], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[2], (gpointer ) userinfo);

	g_signal_emitv (___param_values,
		object_signals[USER_INFO_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
	g_value_unset (&___param_values[2]);
}
#line 399 "gnome-pilot-client.gob"
static void 
___real_gnome_pilot_client_user_info (GnomePilotClient * self G_GNUC_UNUSED, const gchar * device, const GNOME_Pilot_UserInfo * userinfo)
#line 1387 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::user_info"
{
#line 400 "gnome-pilot-client.gob"
	
		return;
	}}
#line 1395 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 404 "gnome-pilot-client.gob"
void 
gnome_pilot_client_system_info (GnomePilotClient * self, const gchar * device, const GNOME_Pilot_SysInfo * sysinfo)
#line 1401 "gnome-pilot-client.c"
{
	GValue ___param_values[3];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 404 "gnome-pilot-client.gob"
	g_return_if_fail (self != NULL);
#line 404 "gnome-pilot-client.gob"
	g_return_if_fail (GNOME_IS_PILOT_CLIENT (self));
#line 1413 "gnome-pilot-client.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) device);

	___param_values[2].g_type = 0;
	g_value_init (&___param_values[2], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[2], (gpointer ) sysinfo);

	g_signal_emitv (___param_values,
		object_signals[SYSTEM_INFO_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
	g_value_unset (&___param_values[2]);
}
#line 404 "gnome-pilot-client.gob"
static void 
___real_gnome_pilot_client_system_info (GnomePilotClient * self G_GNUC_UNUSED, const gchar * device, const GNOME_Pilot_SysInfo * sysinfo)
#line 1439 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::system_info"
{
#line 405 "gnome-pilot-client.gob"
	
		return;
	}}
#line 1447 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 409 "gnome-pilot-client.gob"
void 
gnome_pilot_client_start_conduit (GnomePilotClient * self, const gchar * pilot_name, const gchar * conduit_name, const gchar * database)
#line 1453 "gnome-pilot-client.c"
{
	GValue ___param_values[4];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 409 "gnome-pilot-client.gob"
	g_return_if_fail (self != NULL);
#line 409 "gnome-pilot-client.gob"
	g_return_if_fail (GNOME_IS_PILOT_CLIENT (self));
#line 1465 "gnome-pilot-client.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) pilot_name);

	___param_values[2].g_type = 0;
	g_value_init (&___param_values[2], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[2], (gpointer ) conduit_name);

	___param_values[3].g_type = 0;
	g_value_init (&___param_values[3], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[3], (gpointer ) database);

	g_signal_emitv (___param_values,
		object_signals[START_CONDUIT_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
	g_value_unset (&___param_values[2]);
	g_value_unset (&___param_values[3]);
}
#line 409 "gnome-pilot-client.gob"
static void 
___real_gnome_pilot_client_start_conduit (GnomePilotClient * self G_GNUC_UNUSED, const gchar * pilot_name, const gchar * conduit_name, const gchar * database)
#line 1496 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::start_conduit"
{
#line 410 "gnome-pilot-client.gob"
	
		return;
	}}
#line 1504 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 414 "gnome-pilot-client.gob"
void 
gnome_pilot_client_end_conduit (GnomePilotClient * self, const gchar * pilot_name, const gchar * conduit_name)
#line 1510 "gnome-pilot-client.c"
{
	GValue ___param_values[3];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 414 "gnome-pilot-client.gob"
	g_return_if_fail (self != NULL);
#line 414 "gnome-pilot-client.gob"
	g_return_if_fail (GNOME_IS_PILOT_CLIENT (self));
#line 1522 "gnome-pilot-client.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) pilot_name);

	___param_values[2].g_type = 0;
	g_value_init (&___param_values[2], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[2], (gpointer ) conduit_name);

	g_signal_emitv (___param_values,
		object_signals[END_CONDUIT_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
	g_value_unset (&___param_values[2]);
}
#line 414 "gnome-pilot-client.gob"
static void 
___real_gnome_pilot_client_end_conduit (GnomePilotClient * self G_GNUC_UNUSED, const gchar * pilot_name, const gchar * conduit_name)
#line 1548 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::end_conduit"
{
#line 415 "gnome-pilot-client.gob"
	
		return;
	}}
#line 1556 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 419 "gnome-pilot-client.gob"
void 
gnome_pilot_client_progress_conduit (GnomePilotClient * self, const gchar * pilot_name, const gchar * conduit_name, guint current, guint total)
#line 1562 "gnome-pilot-client.c"
{
	GValue ___param_values[5];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 419 "gnome-pilot-client.gob"
	g_return_if_fail (self != NULL);
#line 419 "gnome-pilot-client.gob"
	g_return_if_fail (GNOME_IS_PILOT_CLIENT (self));
#line 1574 "gnome-pilot-client.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) pilot_name);

	___param_values[2].g_type = 0;
	g_value_init (&___param_values[2], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[2], (gpointer ) conduit_name);

	___param_values[3].g_type = 0;
	g_value_init (&___param_values[3], G_TYPE_UINT);
	g_value_set_uint (&___param_values[3], (guint ) current);

	___param_values[4].g_type = 0;
	g_value_init (&___param_values[4], G_TYPE_UINT);
	g_value_set_uint (&___param_values[4], (guint ) total);

	g_signal_emitv (___param_values,
		object_signals[PROGRESS_CONDUIT_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
	g_value_unset (&___param_values[2]);
	g_value_unset (&___param_values[3]);
	g_value_unset (&___param_values[4]);
}
#line 419 "gnome-pilot-client.gob"
static void 
___real_gnome_pilot_client_progress_conduit (GnomePilotClient * self G_GNUC_UNUSED, const gchar * pilot_name, const gchar * conduit_name, guint current, guint total)
#line 1610 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::progress_conduit"
{
#line 420 "gnome-pilot-client.gob"
	
		return;
	}}
#line 1618 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 424 "gnome-pilot-client.gob"
void 
gnome_pilot_client_progress_overall (GnomePilotClient * self, const gchar * pilot_name, guint current, guint total)
#line 1624 "gnome-pilot-client.c"
{
	GValue ___param_values[4];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 424 "gnome-pilot-client.gob"
	g_return_if_fail (self != NULL);
#line 424 "gnome-pilot-client.gob"
	g_return_if_fail (GNOME_IS_PILOT_CLIENT (self));
#line 1636 "gnome-pilot-client.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) pilot_name);

	___param_values[2].g_type = 0;
	g_value_init (&___param_values[2], G_TYPE_UINT);
	g_value_set_uint (&___param_values[2], (guint ) current);

	___param_values[3].g_type = 0;
	g_value_init (&___param_values[3], G_TYPE_UINT);
	g_value_set_uint (&___param_values[3], (guint ) total);

	g_signal_emitv (___param_values,
		object_signals[PROGRESS_OVERALL_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
	g_value_unset (&___param_values[2]);
	g_value_unset (&___param_values[3]);
}

#line 430 "gnome-pilot-client.gob"
void 
gnome_pilot_client_message_conduit (GnomePilotClient * self, const gchar * pilot_name, const gchar * conduit_name, const gchar * message)
#line 1668 "gnome-pilot-client.c"
{
	GValue ___param_values[4];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 430 "gnome-pilot-client.gob"
	g_return_if_fail (self != NULL);
#line 430 "gnome-pilot-client.gob"
	g_return_if_fail (GNOME_IS_PILOT_CLIENT (self));
#line 1680 "gnome-pilot-client.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) pilot_name);

	___param_values[2].g_type = 0;
	g_value_init (&___param_values[2], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[2], (gpointer ) conduit_name);

	___param_values[3].g_type = 0;
	g_value_init (&___param_values[3], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[3], (gpointer ) message);

	g_signal_emitv (___param_values,
		object_signals[MESSAGE_CONDUIT_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
	g_value_unset (&___param_values[2]);
	g_value_unset (&___param_values[3]);
}
#line 430 "gnome-pilot-client.gob"
static void 
___real_gnome_pilot_client_message_conduit (GnomePilotClient * self G_GNUC_UNUSED, const gchar * pilot_name, const gchar * conduit_name, const gchar * message)
#line 1711 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::message_conduit"
{
#line 431 "gnome-pilot-client.gob"
	
		return;
	}}
#line 1719 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 435 "gnome-pilot-client.gob"
void 
gnome_pilot_client_message_daemon (GnomePilotClient * self, const gchar * pilot_name, const gchar * conduit_name, const gchar * message)
#line 1725 "gnome-pilot-client.c"
{
	GValue ___param_values[4];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 435 "gnome-pilot-client.gob"
	g_return_if_fail (self != NULL);
#line 435 "gnome-pilot-client.gob"
	g_return_if_fail (GNOME_IS_PILOT_CLIENT (self));
#line 1737 "gnome-pilot-client.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) pilot_name);

	___param_values[2].g_type = 0;
	g_value_init (&___param_values[2], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[2], (gpointer ) conduit_name);

	___param_values[3].g_type = 0;
	g_value_init (&___param_values[3], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[3], (gpointer ) message);

	g_signal_emitv (___param_values,
		object_signals[MESSAGE_DAEMON_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
	g_value_unset (&___param_values[2]);
	g_value_unset (&___param_values[3]);
}
#line 435 "gnome-pilot-client.gob"
static void 
___real_gnome_pilot_client_message_daemon (GnomePilotClient * self G_GNUC_UNUSED, const gchar * pilot_name, const gchar * conduit_name, const gchar * message)
#line 1768 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::message_daemon"
{
#line 436 "gnome-pilot-client.gob"
	
		return;
	}}
#line 1776 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 440 "gnome-pilot-client.gob"
void 
gnome_pilot_client_error_daemon (GnomePilotClient * self, const gchar * pilot_name, const gchar * message)
#line 1782 "gnome-pilot-client.c"
{
	GValue ___param_values[3];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 440 "gnome-pilot-client.gob"
	g_return_if_fail (self != NULL);
#line 440 "gnome-pilot-client.gob"
	g_return_if_fail (GNOME_IS_PILOT_CLIENT (self));
#line 1794 "gnome-pilot-client.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) pilot_name);

	___param_values[2].g_type = 0;
	g_value_init (&___param_values[2], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[2], (gpointer ) message);

	g_signal_emitv (___param_values,
		object_signals[ERROR_DAEMON_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
	g_value_unset (&___param_values[2]);
}
#line 440 "gnome-pilot-client.gob"
static void 
___real_gnome_pilot_client_error_daemon (GnomePilotClient * self G_GNUC_UNUSED, const gchar * pilot_name, const gchar * message)
#line 1820 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::error_daemon"
{
#line 441 "gnome-pilot-client.gob"
	
		return;
	}}
#line 1828 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 445 "gnome-pilot-client.gob"
void 
gnome_pilot_client_error_conduit (GnomePilotClient * self, const gchar * pilot_name, const gchar * conduit_name, const gchar * message)
#line 1834 "gnome-pilot-client.c"
{
	GValue ___param_values[4];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 445 "gnome-pilot-client.gob"
	g_return_if_fail (self != NULL);
#line 445 "gnome-pilot-client.gob"
	g_return_if_fail (GNOME_IS_PILOT_CLIENT (self));
#line 1846 "gnome-pilot-client.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) pilot_name);

	___param_values[2].g_type = 0;
	g_value_init (&___param_values[2], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[2], (gpointer ) conduit_name);

	___param_values[3].g_type = 0;
	g_value_init (&___param_values[3], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[3], (gpointer ) message);

	g_signal_emitv (___param_values,
		object_signals[ERROR_CONDUIT_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
	g_value_unset (&___param_values[2]);
	g_value_unset (&___param_values[3]);
}
#line 445 "gnome-pilot-client.gob"
static void 
___real_gnome_pilot_client_error_conduit (GnomePilotClient * self G_GNUC_UNUSED, const gchar * pilot_name, const gchar * conduit_name, const gchar * message)
#line 1877 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::error_conduit"
{
#line 446 "gnome-pilot-client.gob"
	
		return;
	}}
#line 1885 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 450 "gnome-pilot-client.gob"
void 
gnome_pilot_client_daemon_pause (GnomePilotClient * self, gboolean on_off)
#line 1891 "gnome-pilot-client.c"
{
	GValue ___param_values[2];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 450 "gnome-pilot-client.gob"
	g_return_if_fail (self != NULL);
#line 450 "gnome-pilot-client.gob"
	g_return_if_fail (GNOME_IS_PILOT_CLIENT (self));
#line 1903 "gnome-pilot-client.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_BOOLEAN);
	g_value_set_boolean (&___param_values[1], (gboolean ) on_off);

	g_signal_emitv (___param_values,
		object_signals[DAEMON_PAUSE_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
}
#line 450 "gnome-pilot-client.gob"
static void 
___real_gnome_pilot_client_daemon_pause (GnomePilotClient * self G_GNUC_UNUSED, gboolean on_off)
#line 1924 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::daemon_pause"
{
#line 451 "gnome-pilot-client.gob"
	
		return;
	}}
#line 1932 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 455 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_pause_daemon (GnomePilotClient * self)
#line 1938 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::pause_daemon"
#line 455 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 455 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 1945 "gnome-pilot-client.c"
{
#line 455 "gnome-pilot-client.gob"
	
		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);

		GNOME_Pilot_Daemon_pause (self->gpilotddaemon,TRUE,&self->ev);
		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}
		return GPILOTD_OK;
	}}
#line 1959 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 467 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_unpause_daemon (GnomePilotClient * self)
#line 1965 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::unpause_daemon"
#line 467 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 467 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 1972 "gnome-pilot-client.c"
{
#line 467 "gnome-pilot-client.gob"
	
		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);

		GNOME_Pilot_Daemon_pause (self->gpilotddaemon,FALSE,&self->ev);
		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}
		return GPILOTD_OK;
        }}
#line 1986 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 479 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_reread_config (GnomePilotClient * self)
#line 1992 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::reread_config"
#line 479 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 479 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 1999 "gnome-pilot-client.c"
{
#line 479 "gnome-pilot-client.gob"
	
		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);

		GNOME_Pilot_Daemon_reread_config (self->gpilotddaemon, &self->ev);
		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}

		return GPILOTD_OK;
        }}
#line 2014 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 492 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_noop (GnomePilotClient * self)
#line 2020 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::noop"
#line 492 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 492 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 2027 "gnome-pilot-client.c"
{
#line 492 "gnome-pilot-client.gob"
	
		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);

		GNOME_Pilot_Daemon_noop (self->gpilotddaemon, &self->ev);
		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_NOT_CONNECTED;
		}
		return GPILOTD_OK;
	}}
#line 2041 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 504 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_restart_daemon (GnomePilotClient * self)
#line 2047 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::restart_daemon"
#line 504 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 504 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 2054 "gnome-pilot-client.c"
{
#line 504 "gnome-pilot-client.gob"
	
		pid_t pid;
		
		/* NOTE: this is going to suck when gpilotd is running on another machine... */
		pid = gpilotd_get_pid ();
		if (pid != -1) {
			/* FIXME shouldn't have to sleep */
			kill (pid, SIGTERM);
			sleep(1);
		}
		return self_connect_to_daemon (self);
        }}
#line 2069 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 517 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_monitor_on (GnomePilotClient * self, const gchar * pilot_id)
#line 2075 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::monitor_on"
#line 517 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 517 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 517 "gnome-pilot-client.gob"
	g_return_val_if_fail (pilot_id != NULL, (gint )GPILOTD_ERR_INVAL);
#line 2084 "gnome-pilot-client.c"
{
#line 518 "gnome-pilot-client.gob"
	
		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);
		g_return_val_if_fail (self->gpilotdclient!=NULL, GPILOTD_ERR_INTERNAL);
		GNOME_Pilot_Daemon_monitor_on (self->gpilotddaemon,self->gpilotdclient,pilot_id,&self->ev);
		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}
		return GPILOTD_OK;
	}}
#line 2098 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 530 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_monitor_on_all_pilots (GnomePilotClient * self)
#line 2104 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::monitor_on_all_pilots"
#line 530 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )0);
#line 530 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )0);
#line 2111 "gnome-pilot-client.c"
{
#line 530 "gnome-pilot-client.gob"
	
		GList   *pilots = NULL,
			*ptr;
		gint ret = GPILOTD_OK;
		
		if (self_get_pilots (self,&pilots) != GPILOTD_OK) return GPILOTD_ERR_FAILED;
		
		for (ptr = pilots; ptr; ptr = ptr->next) {
			ret = self_monitor_on (self,(gchar*)ptr->data);
		}
		g_list_foreach (pilots,(GFunc)g_free,NULL);
		return ret;
        }}
#line 2127 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 544 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_monitor_off (GnomePilotClient * self, const gchar * pilot_id)
#line 2133 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::monitor_off"
#line 544 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 544 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 544 "gnome-pilot-client.gob"
	g_return_val_if_fail (pilot_id != NULL, (gint )GPILOTD_ERR_INVAL);
#line 2142 "gnome-pilot-client.c"
{
#line 545 "gnome-pilot-client.gob"
	
		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);
		g_return_val_if_fail (self->gpilotdclient!=NULL, GPILOTD_ERR_INTERNAL);

		GNOME_Pilot_Daemon_monitor_off (self->gpilotddaemon,self->gpilotdclient,pilot_id,&self->ev);
		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}
		return GPILOTD_OK;
	}}
#line 2157 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 558 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_monitor_off_all_pilots (GnomePilotClient * self)
#line 2163 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::monitor_off_all_pilots"
#line 558 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )0);
#line 558 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )0);
#line 2170 "gnome-pilot-client.c"
{
#line 558 "gnome-pilot-client.gob"
	
		GList   *pilots = NULL,
			*ptr;
		gint ret = GPILOTD_OK;
		
		if (self_get_pilots (self,&pilots) != GPILOTD_OK) return GPILOTD_ERR_FAILED;
		
		for (ptr = pilots; ptr; ptr = ptr->next) {
			ret = self_monitor_on (self,(gchar*)ptr->data);
		}
		g_list_foreach (pilots,(GFunc)g_free,NULL);
		return ret;
	}}
#line 2186 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 572 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_notify_on (GnomePilotClient * self, GNOME_Pilot_EventType type)
#line 2192 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::notify_on"
#line 572 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )0);
#line 572 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )0);
#line 2199 "gnome-pilot-client.c"
{
#line 573 "gnome-pilot-client.gob"
	
		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);
		g_return_val_if_fail (self->gpilotdclient!=NULL, GPILOTD_ERR_INTERNAL);

		GNOME_Pilot_Daemon_notify_on (self->gpilotddaemon,type,self->gpilotdclient,&self->ev);
		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}
		return GPILOTD_OK;
	}}
#line 2214 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 586 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_notify_off (GnomePilotClient * self, GNOME_Pilot_EventType type)
#line 2220 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::notify_off"
#line 586 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 586 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 2227 "gnome-pilot-client.c"
{
#line 587 "gnome-pilot-client.gob"
	
		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);
		g_return_val_if_fail (self->gpilotdclient!=NULL, GPILOTD_ERR_INTERNAL);

		GNOME_Pilot_Daemon_notify_off (self->gpilotddaemon,type,self->gpilotdclient,&self->ev);
		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}
		return GPILOTD_OK;
	}}
#line 2242 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 600 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_restore (GnomePilotClient * self, const gchar * pilot_id, const gchar * directory, GNOME_Pilot_Survival survival, gint timeout, gint * handle)
#line 2248 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::restore"
#line 600 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 600 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 600 "gnome-pilot-client.gob"
	g_return_val_if_fail (pilot_id != NULL, (gint )GPILOTD_ERR_INVAL);
#line 600 "gnome-pilot-client.gob"
	g_return_val_if_fail (directory != NULL, (gint )GPILOTD_ERR_INVAL);
#line 600 "gnome-pilot-client.gob"
	g_return_val_if_fail (timeout >= 0, (gint )GPILOTD_ERR_INVAL);
#line 2261 "gnome-pilot-client.c"
{
#line 605 "gnome-pilot-client.gob"
	
		gint val;

		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);
		g_return_val_if_fail (self->gpilotdclient!=NULL, GPILOTD_ERR_INTERNAL);

		val = GNOME_Pilot_Daemon_request_restore (self->gpilotddaemon,
							 self->gpilotdclient,
							 pilot_id,
							 directory,
							 survival,
							 timeout,
							 &self->ev);
		switch (self->ev._major) {
		case CORBA_SYSTEM_EXCEPTION:
		case CORBA_USER_EXCEPTION: {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			if (strcmp (ex_GNOME_Pilot_MissingFile,CORBA_exception_id (&self->ev))==0) {
				g_warning ("Missing file");
			} 
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
			break;
		}
		case CORBA_NO_EXCEPTION: 
		default:
			break;
		}

		if (handle!=NULL) *handle = val;

		return GPILOTD_OK;
	}}
#line 2297 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 639 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_install_file (GnomePilotClient * self, const gchar * pilot_name, const gchar * infile, GNOME_Pilot_Survival survival, gint timeout, gint * handle)
#line 2303 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::install_file"
#line 639 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 639 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 639 "gnome-pilot-client.gob"
	g_return_val_if_fail (pilot_name != NULL, (gint )GPILOTD_ERR_INVAL);
#line 639 "gnome-pilot-client.gob"
	g_return_val_if_fail (infile != NULL, (gint )GPILOTD_ERR_INVAL);
#line 639 "gnome-pilot-client.gob"
	g_return_val_if_fail (timeout >= 0, (gint )GPILOTD_ERR_INVAL);
#line 2316 "gnome-pilot-client.c"
{
#line 644 "gnome-pilot-client.gob"
	
		gint val;
		gboolean file_copied = FALSE;
		gchar *filename;

		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);
		g_return_val_if_fail (self->gpilotdclient!=NULL, GPILOTD_ERR_INTERNAL);
	       
		/* g_message ("Installing %s to %s", infile, pilot_name); */

#ifdef WITH_VFS
		{
			GnomeVFSResult result;
			GnomeVFSXferOptions xfer_options = 0;
			GnomeVFSURI *src_uri;
			GnomeVFSURI *dest_uri;
			char *filename_uri;
			char pwd[128];
			char *infile_with_path;
			gchar *queue;

			queue = g_strdup_printf ("%s/.gpilotd/",g_get_home_dir ());
			filename = tempnam (queue,"PDB");
						
			filename_uri = g_strdup_printf ("file://%s", filename);

			/*
			g_message ("%s test is %d %d", infile, 
				   infile[0] != '/',
				   strncmp (infile, "file:/", 6)!=0);
			*/

			if (infile[0] != '/' && strncmp (infile, "file:/", 6)!=0) {
				/* gnomevfs needs the file with path */
				getcwd (pwd, 127);
				infile_with_path = g_strdup_printf ("%s/%s", pwd, infile);
			} else {
				infile_with_path = g_strdup (infile);
			}

			src_uri = gnome_vfs_uri_new (infile_with_path);
			dest_uri = gnome_vfs_uri_new (filename_uri);

			/*
			g_message ("from : \"%s\"", infile_with_path);
			g_message ("to   : \"%s\"", filename_uri);
			*/

			result = gnome_vfs_xfer_uri (src_uri, dest_uri,
						     xfer_options,
						     GNOME_VFS_XFER_ERROR_MODE_QUERY,
						     GNOME_VFS_XFER_OVERWRITE_MODE_QUERY,
						     (GnomeVFSXferProgressCallback)xfer_callback, 
						     self);

			/* g_message ("gnome-vfs-xfer-uri: %s\n",gnome_vfs_result_to_string (result));  */

			if (result == GNOME_VFS_OK) {
				file_copied = TRUE;
			} else {
				file_copied = FALSE;
			}
			g_free (filename_uri);
			gnome_vfs_uri_unref (src_uri);
			gnome_vfs_uri_unref (dest_uri);
			g_free (queue);
			g_free (infile_with_path);			
		}
#else /* WITH_VFS */
		{
			gchar *queue;
			FILE *in,*out;

			file_copied = TRUE;

			queue = g_strdup_printf ("%s/.gnome2/gnome-pilot.d/",g_get_home_dir ());
			filename = tempnam (queue,"PDB");			
			
			in = fopen (infile,"rb");
			if (in==NULL) {
				file_copied = FALSE;
			} 

			out = fopen (filename,"wb");
			if (out==NULL) {
				file_copied = FALSE;
			}
			
			while (!feof (in)) {
				size_t act;
				char block[1024];
				act=fread (block,1,1024,in);
				if (ferror (in)) {
					file_copied = FALSE;
				}
				if (fwrite (block,1,act,out)!=act) {
					file_copied = FALSE;
				}
				if (ferror (out)) {
					file_copied = FALSE;
				}
			}
			
			if (out) {
				fflush (out);
			}
			if (in) {
				fclose (in); 
			}
			if (out) {
				fclose (out);		
			}
			g_free (queue);
		}
#endif /* WITH_VFS */
		if (file_copied == FALSE) {
#ifndef WITH_VFS
			g_message ("File copy failed");
#endif
			free (filename);
			return GPILOTD_ERR_FAILED;
		}

		val = GNOME_Pilot_Daemon_request_install (self->gpilotddaemon,
							 self->gpilotdclient,
							 pilot_name,
							 filename,
							 infile,
							 survival,
							 timeout,
							 &self->ev);
		switch (self->ev._major) {
		case CORBA_NO_EXCEPTION: 
			break;
		case CORBA_SYSTEM_EXCEPTION:
		case CORBA_USER_EXCEPTION:
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			
			if (strcmp (ex_GNOME_Pilot_MissingFile,CORBA_exception_id (&self->ev))==0) {
				g_warning ("Missing file");
			} else {
				unlink (filename);
			}
			CORBA_exception_free (&self->ev);
			free (filename);
			return GPILOTD_ERR_FAILED;
			break;
		default:
			break;
		}

		if (handle!=NULL) *handle = val;

		free (filename);
		return GPILOTD_OK;
	}}
#line 2475 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 801 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_get_user_info (GnomePilotClient * self, gchar * cradle_name, GNOME_Pilot_Survival survival, gint timeout, gint * handle)
#line 2481 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::get_user_info"
#line 801 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 801 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 801 "gnome-pilot-client.gob"
	g_return_val_if_fail (cradle_name != NULL, (gint )GPILOTD_ERR_INVAL);
#line 801 "gnome-pilot-client.gob"
	g_return_val_if_fail (timeout >= 0, (gint )GPILOTD_ERR_INVAL);
#line 2492 "gnome-pilot-client.c"
{
#line 805 "gnome-pilot-client.gob"
	
		gint val;

		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);
		g_return_val_if_fail (self->gpilotdclient!=NULL, GPILOTD_ERR_INTERNAL);

		val = GNOME_Pilot_Daemon_get_user_info (self->gpilotddaemon,
						       self->gpilotdclient,
						       cradle_name,
						       survival,
						       timeout,
						       &self->ev);

		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}

		if (handle!=NULL) *handle =val;

		return GPILOTD_OK;
	}}
#line 2518 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 829 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_set_user_info (GnomePilotClient * self, gchar * cradle_name, GNOME_Pilot_UserInfo user, gboolean continue_sync, GNOME_Pilot_Survival survival, gint timeout, gint * handle)
#line 2524 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::set_user_info"
#line 829 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 829 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 829 "gnome-pilot-client.gob"
	g_return_val_if_fail (cradle_name != NULL, (gint )GPILOTD_ERR_INVAL);
#line 829 "gnome-pilot-client.gob"
	g_return_val_if_fail (timeout >= 0, (gint )GPILOTD_ERR_INVAL);
#line 2535 "gnome-pilot-client.c"
{
#line 835 "gnome-pilot-client.gob"
	
		gint val;

		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);
		g_return_val_if_fail (self->gpilotdclient!=NULL, GPILOTD_ERR_INTERNAL);

		val = GNOME_Pilot_Daemon_set_user_info (self->gpilotddaemon,
						       self->gpilotdclient,
						       &user,
						       cradle_name,
						       continue_sync,
						       survival,
						       timeout,
						       &self->ev);

		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}

		if (handle!=NULL) *handle =val;

		return GPILOTD_OK;
	}}
#line 2563 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 861 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_get_system_info (GnomePilotClient * self, gchar * cradle_name, GNOME_Pilot_Survival survival, gint timeout, gint * handle)
#line 2569 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::get_system_info"
#line 861 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 861 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 861 "gnome-pilot-client.gob"
	g_return_val_if_fail (cradle_name != NULL, (gint )GPILOTD_ERR_INVAL);
#line 2578 "gnome-pilot-client.c"
{
#line 865 "gnome-pilot-client.gob"
	
		gint val;

		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);
		g_return_val_if_fail (self->gpilotdclient!=NULL, GPILOTD_ERR_INTERNAL);

		val = GNOME_Pilot_Daemon_get_system_info (self->gpilotddaemon,
							 self->gpilotdclient,
							 cradle_name,
							 survival,
							 timeout,
							 &self->ev);

		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}

		if (handle!=NULL) *handle =val;

		return GPILOTD_OK;
	}}
#line 2604 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 889 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_remove_request (GnomePilotClient * self, gint handle)
#line 2610 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::remove_request"
#line 889 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 889 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 2617 "gnome-pilot-client.c"
{
#line 890 "gnome-pilot-client.gob"
	
		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);
		g_return_val_if_fail (self->gpilotdclient!=NULL, GPILOTD_ERR_INTERNAL);

		GNOME_Pilot_Daemon_remove_request (self->gpilotddaemon,handle,&self->ev);
		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}
		return GPILOTD_OK;		
	}}
#line 2632 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 903 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_conduit (GnomePilotClient * self, const gchar * pilot_name, const gchar * conduit_name, GNOME_Pilot_ConduitOperation operation, GNOME_Pilot_Survival survival, gint timeout, gint * handle)
#line 2638 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::conduit"
#line 903 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 903 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 903 "gnome-pilot-client.gob"
	g_return_val_if_fail (pilot_name != NULL, (gint )GPILOTD_ERR_INVAL);
#line 903 "gnome-pilot-client.gob"
	g_return_val_if_fail (conduit_name != NULL, (gint )GPILOTD_ERR_INVAL);
#line 903 "gnome-pilot-client.gob"
	g_return_val_if_fail (timeout >= 0, (gint )GPILOTD_ERR_INVAL);
#line 2651 "gnome-pilot-client.c"
{
#line 909 "gnome-pilot-client.gob"
	
		gint val;

		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);
		g_return_val_if_fail (self->gpilotdclient!=NULL, GPILOTD_ERR_INTERNAL);
		
		val = GNOME_Pilot_Daemon_request_conduit (self->gpilotddaemon,
							 self->gpilotdclient,
							 pilot_name,
							 conduit_name,
							 operation,
							 survival,
							 timeout,
							 &self->ev);
		
		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}

		if (handle!=NULL) *handle =val;

		return GPILOTD_OK;
	}}
#line 2679 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 935 "gnome-pilot-client.gob"
static gint 
gnome_pilot_client_get_triple_ptr (GnomePilotClient * self, enum get_triple_ptr_action action, const gchar * name, GList ** output)
#line 2685 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::get_triple_ptr"
#line 935 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 935 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 935 "gnome-pilot-client.gob"
	g_return_val_if_fail (output != NULL, (gint )GPILOTD_ERR_INVAL);
#line 2694 "gnome-pilot-client.c"
{
#line 938 "gnome-pilot-client.gob"
	
		GNOME_Pilot_StringSequence *seq=NULL;
		GNOME_Pilot_LongSequence *seq_long=NULL;
	
#ifndef G_DISABLE_CHECKS		
		if (*output!=NULL) {
			g_warning ("%s:%d: get_triple_ptr called with non-null pointer for output, leak-alert!",
				  __FILE__,__LINE__);
		}
#endif
		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);

		(*output) = NULL;

		switch (action) {
		case GPILOTD_APP_PILOT_NAMES:
			seq = GNOME_Pilot_Daemon_get_pilots (self->gpilotddaemon, &self->ev);
			break;
		case GPILOTD_APP_PILOT_IDS:
			seq_long = GNOME_Pilot_Daemon_get_pilot_ids (self->gpilotddaemon, &self->ev);
			break;
		case GPILOTD_APP_PILOTS_BY_NAME:
			seq = GNOME_Pilot_Daemon_get_pilots_by_user_name (self->gpilotddaemon,name,&self->ev);
			break;
		case GPILOTD_APP_PILOTS_BY_LOGIN:
			seq = GNOME_Pilot_Daemon_get_pilots_by_user_login (self->gpilotddaemon,name,&self->ev);
			break;
		case GPILOTD_APP_USER_NAMES:
			seq = GNOME_Pilot_Daemon_get_users (self->gpilotddaemon,&self->ev);
			break;
		case GPILOTD_APP_DATABASES_FROM_CACHE:
			seq = GNOME_Pilot_Daemon_get_databases_from_cache (self->gpilotddaemon,name,&self->ev);
			break;
		case GPILOTD_APP_CRADLES:
			seq = GNOME_Pilot_Daemon_get_cradles (self->gpilotddaemon,&self->ev);
			break;
		}
		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}
		if (seq && seq->_length>0) {
			int i;
			for (i=0;i<seq->_length;i++) {
				if (strlen (seq->_buffer[i]))
					(*output) = g_list_append ((*output),g_strdup (seq->_buffer[i]));
			}
		} 
		if (seq_long && seq_long->_length>0) {
			int i;
			for (i=0;i<seq_long->_length;i++) {
				(*output) = g_list_append ((*output),
							   GINT_TO_POINTER (seq_long->_buffer[i]));
			}
		} 
		
		CORBA_free (seq);
		CORBA_free (seq_long);

		return GPILOTD_OK;
	}}
#line 2759 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 1001 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_get_users (GnomePilotClient * self, GList ** output)
#line 2765 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::get_users"
#line 1001 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1001 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 1001 "gnome-pilot-client.gob"
	g_return_val_if_fail (output != NULL, (gint )GPILOTD_ERR_INVAL);
#line 2774 "gnome-pilot-client.c"
{
#line 1002 "gnome-pilot-client.gob"
	
		return self_get_triple_ptr (self,GPILOTD_APP_USER_NAMES,NULL,output);
	}}
#line 2780 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 1006 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_get_databases_from_cache (GnomePilotClient * self, const gchar * pilot_name, GList ** output)
#line 2786 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::get_databases_from_cache"
#line 1006 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1006 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 1006 "gnome-pilot-client.gob"
	g_return_val_if_fail (output != NULL, (gint )GPILOTD_ERR_INVAL);
#line 2795 "gnome-pilot-client.c"
{
#line 1008 "gnome-pilot-client.gob"
	
		return self_get_triple_ptr (self,GPILOTD_APP_DATABASES_FROM_CACHE,pilot_name,output);
	}}
#line 2801 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 1012 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_get_cradles (GnomePilotClient * self, GList ** output)
#line 2807 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::get_cradles"
#line 1012 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1012 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 1012 "gnome-pilot-client.gob"
	g_return_val_if_fail (output != NULL, (gint )GPILOTD_ERR_INVAL);
#line 2816 "gnome-pilot-client.c"
{
#line 1013 "gnome-pilot-client.gob"
	
		return self_get_triple_ptr (self,GPILOTD_APP_CRADLES,NULL,output);
	}}
#line 2822 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 1017 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_get_pilots (GnomePilotClient * self, GList ** output)
#line 2828 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::get_pilots"
#line 1017 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1017 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 1017 "gnome-pilot-client.gob"
	g_return_val_if_fail (output != NULL, (gint )GPILOTD_ERR_INVAL);
#line 2837 "gnome-pilot-client.c"
{
#line 1018 "gnome-pilot-client.gob"
	
		return self_get_triple_ptr (self,GPILOTD_APP_PILOT_NAMES,NULL,output);
	}}
#line 2843 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 1022 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_get_pilot_ids (GnomePilotClient * self, gint ** output)
#line 2849 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::get_pilot_ids"
#line 1022 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1022 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 1022 "gnome-pilot-client.gob"
	g_return_val_if_fail (output != NULL, (gint )GPILOTD_ERR_INVAL);
#line 2858 "gnome-pilot-client.c"
{
#line 1023 "gnome-pilot-client.gob"
	
		GList *long_output = NULL, *ptr;
		gint result, idx;

		result = self_get_triple_ptr (self, GPILOTD_APP_PILOT_IDS, NULL, &long_output);

		(*output) = g_new0 (int, g_list_length (long_output));
		idx = 0;
		for (ptr = long_output; ptr; ptr = g_list_next (ptr)) {
			(*output)[idx] = GPOINTER_TO_INT (ptr->data);
			idx++;
		}
		g_list_free (long_output);

		return result;
	}}
#line 2877 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 1041 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_get_pilots_by_user_name (GnomePilotClient * self, const gchar * name, GList ** output)
#line 2883 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::get_pilots_by_user_name"
#line 1041 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1041 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 1041 "gnome-pilot-client.gob"
	g_return_val_if_fail (name != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1041 "gnome-pilot-client.gob"
	g_return_val_if_fail (output != NULL, (gint )GPILOTD_ERR_INVAL);
#line 2894 "gnome-pilot-client.c"
{
#line 1043 "gnome-pilot-client.gob"
	
		return self_get_triple_ptr (self,GPILOTD_APP_PILOTS_BY_NAME,name,output);
	}}
#line 2900 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 1047 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_get_pilots_by_user_login (GnomePilotClient * self, const gchar * login, GList ** output)
#line 2906 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::get_pilots_by_user_login"
#line 1047 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1047 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 1047 "gnome-pilot-client.gob"
	g_return_val_if_fail (login != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1047 "gnome-pilot-client.gob"
	g_return_val_if_fail (output != NULL, (gint )GPILOTD_ERR_INVAL);
#line 2917 "gnome-pilot-client.c"
{
#line 1049 "gnome-pilot-client.gob"
	
		return self_get_triple_ptr (self,GPILOTD_APP_PILOTS_BY_LOGIN,login,output);
	}}
#line 2923 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 1053 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_get_user_name_by_pilot_name (GnomePilotClient * self, const gchar * pilot_name, gchar ** output)
#line 2929 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::get_user_name_by_pilot_name"
#line 1053 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1053 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 1053 "gnome-pilot-client.gob"
	g_return_val_if_fail (pilot_name != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1053 "gnome-pilot-client.gob"
	g_return_val_if_fail (output != NULL, (gint )GPILOTD_ERR_INVAL);
#line 2940 "gnome-pilot-client.c"
{
#line 1055 "gnome-pilot-client.gob"
	
		CORBA_char *user_name = NULL;

 		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);
#ifndef G_DISABLE_CHECKS		
		if (*output!=NULL) {
			g_warning ("%s:%d: get_user_name_by_pilot_name called with non-null pointer for output, leak-alert!",
				  __FILE__,__LINE__);
		}
#endif
		user_name = GNOME_Pilot_Daemon_get_user_name_by_pilot_name (self->gpilotddaemon,
									    pilot_name,
									    &self->ev);
		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, 
				   CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}
		
		*output = g_strdup (user_name);
		CORBA_free (user_name);

		return GPILOTD_OK;	
	}}
#line 2968 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 1081 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_get_user_login_by_pilot_name (GnomePilotClient * self, const gchar * pilot_name, gchar ** output)
#line 2974 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::get_user_login_by_pilot_name"
#line 1081 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1081 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 1081 "gnome-pilot-client.gob"
	g_return_val_if_fail (pilot_name != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1081 "gnome-pilot-client.gob"
	g_return_val_if_fail (output != NULL, (gint )GPILOTD_ERR_INVAL);
#line 2985 "gnome-pilot-client.c"
{
#line 1083 "gnome-pilot-client.gob"
	
		CORBA_char *user_login = NULL;

		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);
#ifndef G_DISABLE_CHECKS		
		if (*output!=NULL) {
			g_warning ("%s:%d: get_user_login_by_pilot_name called with non-null pointer for output, leak-alert!",
				  __FILE__,__LINE__);
		}
#endif
		user_login = GNOME_Pilot_Daemon_get_user_login_by_pilot_name (self->gpilotddaemon,
									      pilot_name,
									      &self->ev);
		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, 
				   CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}
		
		*output = g_strdup (user_login);
		CORBA_free (user_login);

		return GPILOTD_OK;	
	}}
#line 3013 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 1113 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_get_pilot_base_dir_by_name (GnomePilotClient * self, const gchar * pilot_name, gchar ** output)
#line 3019 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::get_pilot_base_dir_by_name"
#line 1113 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1113 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 1113 "gnome-pilot-client.gob"
	g_return_val_if_fail (pilot_name != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1113 "gnome-pilot-client.gob"
	g_return_val_if_fail (output != NULL, (gint )GPILOTD_ERR_INVAL);
#line 3030 "gnome-pilot-client.c"
{
#line 1115 "gnome-pilot-client.gob"
	
		CORBA_char *basedir;

		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);
#ifndef G_DISABLE_CHECKS		
		if (*output!=NULL) {
			g_warning ("%s:%d: get_pilot_base_dir_by_name called with non-null pointer for output, leak-alert!",
				  __FILE__,__LINE__);
		}
#endif
		basedir = GNOME_Pilot_Daemon_get_pilot_base_dir (self->gpilotddaemon,pilot_name,&self->ev);
		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}
		
		*output = g_strdup (basedir);
		CORBA_free (basedir);
		
		if (strlen (*output)==0) {
			g_free (*output);
		       *output = g_strdup_printf ("%s/%s",g_get_home_dir (),pilot_name);
		}
		
		return GPILOTD_OK;	
	}}
#line 3060 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 1143 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_get_pilot_base_dir_by_id (GnomePilotClient * self, guint32 pilot_id, gchar ** output)
#line 3066 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::get_pilot_base_dir_by_id"
#line 1143 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1143 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 1143 "gnome-pilot-client.gob"
	g_return_val_if_fail (output != NULL, (gint )GPILOTD_ERR_INVAL);
#line 3075 "gnome-pilot-client.c"
{
#line 1145 "gnome-pilot-client.gob"
	
		gchar *pilot_name;
		gint return_code;

		return_code = self_get_pilot_name_by_id (self,pilot_id,&pilot_name);
		if (return_code!=GPILOTD_OK) {
			return return_code;
		}

		return_code = self_get_pilot_base_dir_by_name (self,pilot_name,output);
		g_free (pilot_name);
		return return_code;
	}}
#line 3091 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 1160 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_get_pilot_id_by_name (GnomePilotClient * self, const gchar * pilot_name, guint32 * output)
#line 3097 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::get_pilot_id_by_name"
#line 1160 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1160 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 1160 "gnome-pilot-client.gob"
	g_return_val_if_fail (pilot_name != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1160 "gnome-pilot-client.gob"
	g_return_val_if_fail (output != NULL, (gint )GPILOTD_ERR_INVAL);
#line 3108 "gnome-pilot-client.c"
{
#line 1162 "gnome-pilot-client.gob"
			
		g_return_val_if_fail (self->gpilotddaemon!=NULL, GPILOTD_ERR_NOT_CONNECTED);
		
		*output = GNOME_Pilot_Daemon_get_pilot_id_from_name (self->gpilotddaemon,pilot_name,&self->ev);
		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}
		
		return GPILOTD_OK;	
	}}
#line 3123 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 1175 "gnome-pilot-client.gob"
gint 
gnome_pilot_client_get_pilot_name_by_id (GnomePilotClient * self, guint32 pilot_id, gchar ** output)
#line 3129 "gnome-pilot-client.c"
{
#define __GOB_FUNCTION__ "Gnome:Pilot:Client::get_pilot_name_by_id"
#line 1175 "gnome-pilot-client.gob"
	g_return_val_if_fail (self != NULL, (gint )GPILOTD_ERR_INVAL);
#line 1175 "gnome-pilot-client.gob"
	g_return_val_if_fail (GNOME_IS_PILOT_CLIENT (self), (gint )GPILOTD_ERR_INVAL);
#line 1175 "gnome-pilot-client.gob"
	g_return_val_if_fail (output != NULL, (gint )GPILOTD_ERR_INVAL);
#line 3138 "gnome-pilot-client.c"
{
#line 1177 "gnome-pilot-client.gob"
	
		CORBA_char *name;
#ifndef G_DISABLE_CHECKS		
		if (*output!=NULL) {
			g_warning ("%s:%d: get_pilot_name_by_id called with non-null pointer for output, leak-alert!",
				  __FILE__,__LINE__);
		}
#endif
		name = GNOME_Pilot_Daemon_get_pilot_name_from_id (self->gpilotddaemon,pilot_id,&self->ev);
		if (self->ev._major != CORBA_NO_EXCEPTION) {
			g_warning ("%s:%d: Caught exception: %s",__FILE__,__LINE__, CORBA_exception_id (&self->ev));
			CORBA_exception_free (&self->ev);
			return GPILOTD_ERR_FAILED;
		}
		
		*output = g_strdup (name);
		CORBA_free (name);
		
		if (output==NULL || strlen (*output)==0) {
			g_free (*output);
			return GPILOTD_ERR_FAILED;
		}
		
		return GPILOTD_OK;	
	}}
#line 3166 "gnome-pilot-client.c"
#undef __GOB_FUNCTION__

#line 1207 "gnome-pilot-client.gob"


#ifdef WITH_VFS
gboolean xfer_callback (GnomeVFSXferProgressInfo *info,
			GnomePilotClient *this) {
	switch (info->status) {
	case GNOME_VFS_XFER_PROGRESS_STATUS_VFSERROR:
		g_message ("VFS Error: %s\n",
			   gnome_vfs_result_to_string (info->vfs_status));
		return FALSE;
		break;
	case GNOME_VFS_XFER_PROGRESS_STATUS_OVERWRITE:
		g_message ("VFS: Overwriting `%s' with `%s'",
			   info->target_name, info->source_name);
		return TRUE;
		break;
	case GNOME_VFS_XFER_PROGRESS_STATUS_OK:
		switch (info->phase) {
		case GNOME_VFS_XFER_PHASE_INITIAL:
			return TRUE;
		case GNOME_VFS_XFER_PHASE_COLLECTING:
			return TRUE;
		case GNOME_VFS_XFER_PHASE_READYTOGO:
			return TRUE;
		case GNOME_VFS_XFER_PHASE_OPENSOURCE:
			return TRUE;
		case GNOME_VFS_XFER_PHASE_OPENTARGET:
			return TRUE;
		case GNOME_VFS_XFER_PHASE_COPYING:
/*
			g_message ("Transferring `%s' to `%s' (file %ld/%ld, byte %ld/%ld in file, "
				   "%" GNOME_VFS_SIZE_FORMAT_STR "/%" GNOME_VFS_SIZE_FORMAT_STR " total)",
				   info->source_name,
				   info->target_name,
				   info->file_index,
				   info->files_total,
				   (glong) info->bytes_copied,
				   (glong) info->file_size,
				   info->total_bytes_copied,
				   info->bytes_total);
*/
			return TRUE;
		case GNOME_VFS_XFER_PHASE_CLOSESOURCE:
			return TRUE;
		case GNOME_VFS_XFER_PHASE_CLOSETARGET:
			return TRUE;
		case GNOME_VFS_XFER_PHASE_FILECOMPLETED:
			return TRUE;
		case GNOME_VFS_XFER_PHASE_COMPLETED:
			return TRUE;
		default:
			/* g_message ("Unexpected phase %d", info->phase); */
			return TRUE; 
		}
		break;
	case GNOME_VFS_XFER_PROGRESS_STATUS_DUPLICATE:
		g_message ("VFS: Duplicate");
		return FALSE;
	default:
		g_message ("VFS: Unknown status");
		return FALSE;
	}       

	g_message ("VFS: doh!");
	return FALSE; 	
		
}
#endif /* WITH_VFS */

pid_t
gpilotd_get_pid (void)
{
	FILE *f;
	const gchar *homedir;
	GString *str;
	gchar pidstr[100];
	pid_t pid;
	
	homedir = g_get_home_dir (); 
	if (!homedir)
		return -1;
	
	str = g_string_new (homedir);
	g_string_append (str, "/.gpilotd.pid");
	f = fopen (str->str, "r");
	g_string_free (str, TRUE);
	if (!f) {
		return -1;
	} else {
		fgets (pidstr, sizeof (pidstr), f);
		fclose (f);
		pid = strtol (pidstr, NULL, 10);
		if (pid == '\0')
			return -1;
		else
			return pid;
	}
}

GnomePilotClient *
get_self (PortableServer_Servant servant) {
	GnomePilotClientServant *s;
	s = (GnomePilotClientServant*)servant;
	return s->self;
}


#line 3277 "gnome-pilot-client.c"
