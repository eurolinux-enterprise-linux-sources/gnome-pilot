/* gnome-pilot-conduit-config.gob
 *
 * Copyright (C) 1999-2000 Free Software Foundation
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 *
 * Authors: Eskil Heyn Olsen
 *          Vadim Strizhevsky
 *
 */

%h{
#include <glib.h>
#include <gtk/gtkobject.h>
#include <gpilotd/gnome-pilot-conduit.h>
#include <libgpilotdCM/gnome-pilot-conduit-management.h>
#include <gmodule.h>
%}

%{
#include <config.h>
%}

class Gnome:Pilot:Conduit:Config from Gtk:Object {
	public GnomePilotConduitSyncType sync_type;
	public GnomePilotConduitSyncType first_sync_type;
	public gboolean first_slow;

	private guint32 pilot_id;
	private GnomePilotConduitManagement *gpcm;

	/*****************************/
	/* Private Utility Functions */
	/*****************************/

	public const gchar *
	sync_type_int_to_str(GnomePilotConduitSyncType e)
	{
		switch(e) {
		case GnomePilotConduitSyncTypeCustom:
			return GnomePilotConduitSyncTypeCustomStr;
		case GnomePilotConduitSyncTypeSynchronize:
			return GnomePilotConduitSyncTypeSynchronizeStr;
		case GnomePilotConduitSyncTypeCopyFromPilot:
			return GnomePilotConduitSyncTypeCopyFromPilotStr;
		case GnomePilotConduitSyncTypeCopyToPilot:
			return GnomePilotConduitSyncTypeCopyToPilotStr;
		case GnomePilotConduitSyncTypeMergeFromPilot:
			return GnomePilotConduitSyncTypeMergeFromPilotStr;
		case GnomePilotConduitSyncTypeMergeToPilot:
			return GnomePilotConduitSyncTypeMergeToPilotStr;
		case GnomePilotConduitSyncTypeNotSet:
			return GnomePilotConduitSyncTypeNotSetStr;
		default: 
		  g_message ("sync_type_int_to_str: invalid sync_type %d",e);
		  return GnomePilotConduitSyncTypeNotSetStr;
		}
	}

	public gint
	sync_type_str_to_int(gchar *s) 
	{
		g_return_val_if_fail(s!=NULL,GnomePilotConduitSyncTypeNotSet);

		if (strcmp (s, GnomePilotConduitSyncTypeSynchronizeStr) == 0) {
			return GnomePilotConduitSyncTypeSynchronize;
		} else if (strcmp (s, GnomePilotConduitSyncTypeCopyToPilotStr) == 0) {
			return GnomePilotConduitSyncTypeCopyToPilot;
		} else if (strcmp (s, GnomePilotConduitSyncTypeCopyFromPilotStr) == 0) {
			return GnomePilotConduitSyncTypeCopyFromPilot;
		} else if (strcmp (s, GnomePilotConduitSyncTypeMergeToPilotStr) == 0) {
			return GnomePilotConduitSyncTypeMergeToPilot;
		} else if (strcmp (s, GnomePilotConduitSyncTypeMergeFromPilotStr) == 0) {
			return GnomePilotConduitSyncTypeMergeFromPilot;
		} else if (strcmp (s, GnomePilotConduitSyncTypeCustomStr) == 0) {
			return GnomePilotConduitSyncTypeCustom;
		} else if (strcmp (s, GnomePilotConduitSyncTypeNotSetStr) == 0) {
			return GnomePilotConduitSyncTypeNotSet;
		}
		return GnomePilotConduitSyncTypeNotSet;
	}

	/***************************/
	/* Initialization          */
	/***************************/

	/* This loads a conduit of a specific type */
	public GnomePilotConduitConfig*
	new(GnomePilotConduitManagement *gpcm, guint32 pilot_id) {
		GtkObject *ret = NULL;
		GnomePilotConduitConfig *obj;

		ret = GTK_OBJECT(GET_NEW);
		obj = SELF(ret);
		obj->_priv->pilot_id = pilot_id;
		obj->_priv->gpcm = gpcm;

		return obj;
	}
	
	/* Destroys this instance of sefl */
        public void
	destroy(self) {
		gtk_object_destroy(GTK_OBJECT(self));
	}

	/***********************************/
	/* CONFIG LOAD/STORE               */
	/***********************************/

	/* Sets the variables to reflect the stat */
	public int
	load_config(self) onerror 0 {
		gchar *prefix,*tmp;

		if(self_is_enabled(self,NULL)==TRUE) {
			prefix = g_strdup_printf("/gnome-pilot.d/conduits%d/%s/",
						 self->_priv->pilot_id,
				                 gnome_pilot_conduit_management_get_id(self->_priv->gpcm));
			gnome_config_push_prefix(prefix);
			tmp = gnome_config_get_string("sync_type");
			if (tmp) {
				self->sync_type = self_sync_type_str_to_int(tmp);
			} else {
				g_warning("conduit has no sync_type, synchronization will skip this conduit");
				self->sync_type = GnomePilotConduitSyncTypeNotSet;
			}
			g_free(tmp);
			tmp = gnome_config_get_string("first_sync_type");
			if (tmp) {
				self->first_sync_type = self_sync_type_str_to_int(tmp);
			} else {
				self->first_sync_type = GnomePilotConduitSyncTypeNotSet;
			}
			g_free(tmp);
			self->first_slow = gnome_config_get_bool("slow_sync");
			gnome_config_pop_prefix();
			g_free(prefix);
		} else 
			return 0;
		return 1;
	} 

	public int
	save_config(self) onerror 0 {
		gchar *prefix;

		if(self_is_enabled(self,NULL)==TRUE) {
			prefix = g_strdup_printf("/gnome-pilot.d/conduits%d/%s/",
						 self->_priv->pilot_id,
				                 gnome_pilot_conduit_management_get_id(self->_priv->gpcm));
			gnome_config_push_prefix(prefix);
			gnome_config_set_string("sync_type",
						self_sync_type_int_to_str(self->sync_type));
			gnome_config_set_string("first_sync_type",
						self_sync_type_int_to_str(self->first_sync_type));
			if(self->first_sync_type==GnomePilotConduitSyncTypeSynchronize) 
			        gnome_config_set_bool("slow_sync",self->first_slow);
			else
			        gnome_config_clean_key("slow_sync");
			gnome_config_pop_prefix();
			gnome_config_sync();
			g_free(prefix);
		} else 
			return 0;
		return 1;
	}

	/***********************************/
	/* CONDUIT EN/DIS-ABLING AND SUCH  */
	/***********************************/

	/* Checks if the conduit is enabled for pilot pilot_id,
	   in which case return val is TRUE, and sync_type
	   if not null set to the sync type */
	public gboolean
	is_enabled(self, 
		   GnomePilotConduitSyncType *sync_type) {
		gchar *tmp;
		int num_conduits,cnt;
		gchar **conduit_name;
		gboolean retval;
		
		retval = FALSE;
		
		tmp = g_strdup_printf("/gnome-pilot.d/conduits%d/General/",
				      self->_priv->pilot_id);
		/* g_message("prefix = %s",tmp); */
		
		/* load the list */
		gnome_config_push_prefix(tmp);
		gnome_config_get_vector("conduits",&num_conduits,&conduit_name);
		gnome_config_pop_prefix();
		
		/* g_message("number_of_conduits = %d",num_conduits); */
		
		/* loop, compare and free */
		for(cnt=0;cnt<num_conduits;cnt++) {
			/* g_message("g_str_equal(%s,%s)",
			   conduit_name[cnt] ,
			   gnome_pilot_conduit_management_get_id(self->_priv->gpcm)); */
			if(g_str_equal(conduit_name[cnt] ,gnome_pilot_conduit_management_get_id(self->_priv->gpcm))) {
				/* g_message("match on %s, it is enabled",conduit_name[cnt]); */
				if(sync_type) {
					gchar *newpfx,*tmpstr;
					newpfx = g_strdup_printf("/gnome-pilot.d/conduits%d/%s/first_sync_type",
								 self->_priv->pilot_id,
								 gnome_pilot_conduit_management_get_id(self->_priv->gpcm));
					tmpstr = gnome_config_get_string(newpfx);
					if (tmpstr == NULL) {
						g_free(newpfx);
						newpfx = g_strdup_printf("/gnome-pilot.d/conduits%d/%s/sync_type",
									 self->_priv->pilot_id,
									 gnome_pilot_conduit_management_get_id(self->_priv->gpcm));

						tmpstr = gnome_config_get_string(newpfx);
					}
					/* g_message("%s says %s",newpfx,tmpstr); */
					(*sync_type) = self_sync_type_str_to_int(tmpstr);
					g_free(newpfx);
					g_free(tmpstr);
				}
				retval = TRUE;
			} 
			g_free(conduit_name[cnt]);
		}
		g_free(conduit_name);
		g_free(tmp);
		return retval;
	}

	/* enable the conduit for pilot pilot_id
	   with the specified synctype */
        public void
	enable(self,
	       GnomePilotConduitSyncType sync_type) {
		gchar *tmp;
		char **conduit_name;
		char **conduit_name_copy;
		int num_conduits,cnt;
	
		/* enable conduit, if it wasn't, otherwise, just write
		   the sync type in case it was changed. */
		if(self_is_enabled(self,NULL)==FALSE) {
			tmp = g_strdup_printf("/gnome-pilot.d/conduits%d/General/",self->_priv->pilot_id);
			/* g_message("prefix = %s",tmp); */
	
			/* load the list of conduits */
			gnome_config_push_prefix(tmp);
			gnome_config_get_vector("conduits",&num_conduits,&conduit_name);
			/* g_message("num_conduits = %d",num_conduits); */
	
			/* copy the list and attach new conduit */
			conduit_name_copy = g_new0(gchar*,num_conduits+2);
			for(cnt=0;cnt<num_conduits;cnt++) {
				/* g_message("duping %d %s",cnt,conduit_name[cnt]); */
				conduit_name_copy[cnt] = g_strdup(conduit_name[cnt]);
				g_free(conduit_name[cnt]);
			}
			g_free(conduit_name);
			/* g_message("adding %s as element %d",gnome_pilot_conduit_management_get_id(self->_priv->gpcm),num_conduits); */ 
			conduit_name_copy[num_conduits] = g_strdup(gnome_pilot_conduit_management_get_id(self->_priv->gpcm));
	
			/* write new list */
			/* g_message("writing new conduits list, size %d",num_conduits+1); */
			gnome_config_set_vector("conduits",num_conduits+1,(const char**)conduit_name_copy);
	
			/* free the copy */
			/* g_message("freeing %d items",num_conduits+1); */
			for(cnt=0;cnt<num_conduits+1;cnt++) {
				/* g_message("should contain %s",conduit_name_copy[cnt]); */
				g_free(conduit_name_copy[cnt]);
			}
			g_free(conduit_name_copy);
	
			gnome_config_pop_prefix();
	
			g_free(tmp);
		}

		/* make section for conduit */
		tmp = g_strdup_printf("/gnome-pilot.d/conduits%d/%s/",
				      self->_priv->pilot_id,
				      gnome_pilot_conduit_management_get_id(self->_priv->gpcm));
		/* g_message("prefix = %s",tmp); */
		gnome_config_push_prefix(tmp);
		gnome_config_set_string("sync_type",
					self_sync_type_int_to_str(sync_type));
		gnome_config_pop_prefix();
		gnome_config_sync();
		g_free(tmp);
	}

	/* enable the conduit for pilot pilot_id
	   with the specified synctype */
	public void
	enable_with_first_sync(self,
			       GnomePilotConduitSyncType sync_type,
			       GnomePilotConduitSyncType first_sync_type,
			       gboolean slow) {
		gchar *tmp;
		
		self_enable(self,sync_type);

		/* add the first_sync info */
		tmp = g_strdup_printf("/gnome-pilot.d/conduits%d/%s/",
				      self->_priv->pilot_id,
				      gnome_pilot_conduit_management_get_id(self->_priv->gpcm));
		gnome_config_push_prefix(tmp);
		gnome_config_set_string("first_sync_type",
					self_sync_type_int_to_str(first_sync_type));
		if(first_sync_type==GnomePilotConduitSyncTypeSynchronize) 
			gnome_config_set_bool("slow_sync",slow);
		else
			gnome_config_clean_key("slow_sync");
		gnome_config_pop_prefix();
		gnome_config_sync();
		g_free(tmp);
	}

	/* clear the first sync flag, if the conduit is not enabled, */
	public void
	remove_first_sync(self) {
		gchar *tmp;
		
		if (self_is_enabled(self,NULL)) {
			/* add the first_sync info */
			tmp = g_strdup_printf("/gnome-pilot.d/conduits%d/%s/",
					      self->_priv->pilot_id,
					      gnome_pilot_conduit_management_get_id(self->_priv->gpcm));
			if (gnome_config_has_section(tmp)) {
				gnome_config_push_prefix(tmp);
				gnome_config_clean_key("first_sync_type");
				gnome_config_clean_key("slow_sync");
				gnome_config_pop_prefix();
			}
			gnome_config_sync();
			g_free(tmp);
		}

		
	}
       
	/* disable the conduit for the pilot */
	public void
	disable(self) {
		gchar *tmp;
		gchar **conduit_name;
		char **conduit_name_copy;
		int num_conduits,num_conduits_copy,cnt;
		
		if(self_is_enabled(self,NULL)==FALSE) return;

		tmp = g_strdup_printf("/gnome-pilot.d/conduits%d/General/",self->_priv->pilot_id);
		
		/* load the list of conduits */
		gnome_config_push_prefix(tmp);
		gnome_config_get_vector("conduits",&num_conduits,&conduit_name);
		
		/* copy the list, excluding the one to delete, num_conduits is > 0 since is_enables succeeded */
		conduit_name_copy = g_new0(char*,num_conduits);
		num_conduits_copy = 0;
		for(cnt=0;cnt<num_conduits;cnt++) {
			if(g_strcasecmp(conduit_name[cnt],gnome_pilot_conduit_management_get_id(self->_priv->gpcm))) {
				/* g_message("keeping %d:%s",cnt,conduit_name[cnt]); */
				conduit_name_copy[num_conduits_copy]=g_strdup(conduit_name[cnt]);
				num_conduits_copy++;
			} else {
				/* g_message("skipping %d:%s",cnt,conduit_name[cnt]); */
			}
			g_free(conduit_name[cnt]);
		}
		g_free(conduit_name);
		
		/* save new list */
		/* g_message("num_conduits_copy = %d",num_conduits_copy); */
		if ( num_conduits_copy > 0 )
			gnome_config_set_vector("conduits",num_conduits_copy,(const char**)conduit_name_copy);
		else
			gnome_config_clean_key("conduits");
		
		/* free copy */
		for(cnt=0;cnt<num_conduits_copy;cnt++) g_free(conduit_name_copy[cnt]);
		g_free(conduit_name_copy);
		
		gnome_config_pop_prefix();
		
		/* nuke the conduits config section */
		g_free(tmp);
		tmp = g_strdup_printf("/gnome-pilot.d/conduits%d/%s/",
				      self->_priv->pilot_id,
				      gnome_pilot_conduit_management_get_id(self->_priv->gpcm));
		gnome_config_clean_section(tmp);
		
		gnome_config_sync();
		g_free(tmp);		
	}

}

%{

%}

